---
applyTo: ".github/agents/**/*"
---

# エージェント開発ガイドライン

## エージェントファイルの構成

エージェントファイルは以下の構造で作成します：

```markdown
---
description: エージェントの説明
name: エージェント名（オプション、省略時はファイル名）
argument-hint: ユーザーへのヒント（オプション）
infer: true/false （デフォルトはtrue、サブエージェントとして使用可能か）
tools:
  - ツール名1
  - ツール名2
model: Claude Sonnet 4（オプション、AIモデル指定）
handoffs:
  - label: 次のステップ
    agent: 遷移先エージェント名
    prompt: 送信するプロンプト
    send: false（デフォルトはfalse、自動送信するか）
---

# エージェント名

{エージェントの指示内容}

ツールの参照: #tool:<tool-name>
```

**重要事項**:
- ファイル拡張子は `.agent.md` を使用
- ファイルは `.github/agents/` ディレクトリに配置
- `infer: false` にするとサブエージェントとして呼び出せなくなる（オーケストレーターなど）
- handoffsを使用すると、エージェント間の遷移をボタンで実現できる

## 利用可能なツール

### VS Code組み込みツール
- `runSubagent`: サブエージェントの呼び出し
- `read`: ファイルの読み取り
- `edit`: ファイルの編集
- `search`: コード検索
- `fetch`: Webページの取得
- `githubRepo`: GitHubリポジトリ検索
- `usages`: コード使用箇所の検索
- `todo`: タスク管理

### ツールの参照方法
エージェントファイルのボディ内でツールを参照する際は、`#tool:<tool-name>` 構文を使用します。

例:
- `#tool:runSubagent` - サブエージェント呼び出しツールを参照
- `#tool:read` - ファイル読み取りツールを参照
- `#tool:edit` - ファイル編集ツールを参照

## オーケストレーターの設計原則

1. **直接編集しない**: オーケストレーターはコードやドキュメントを直接変更しない
2. **指揮に専念**: 高レベルのワークフロー管理のみ行う
3. **サブエージェントへの委譲**: すべての作業はサブエージェントに委譲

## サブエージェントの設計原則

1. **単一責任**: 各サブエージェントは単一の責任を持つ
2. **独立性**: 他のサブエージェントに依存しない
3. **再利用性**: 単独でも使用可能
4. **infer設定**: サブエージェントとして呼び出される場合は、`infer` を `true`（デフォルト）にする

## サブエージェントの呼び出し方法

オーケストレーターからサブエージェントを呼び出す際は、#tool:runSubagent を使用します。

プロンプト内で以下のように指示します：
```
「architect」エージェントをサブエージェントとして使用し、〇〇機能のアーキテクチャを構成してください。
```

サブエージェントは独立した文脈で実行され、完了時に結果のみをメインエージェントに返します。

## Handoffsによるワークフロー管理

handoffsを使用すると、エージェント間の遷移をボタンで実現できます：

```yaml
handoffs:
  - label: 実装開始
    agent: implementer
    prompt: 以下の仕様に基づいて実装を開始してください。
    send: false
```

- `label`: ボタンに表示されるテキスト
- `agent`: 遷移先のエージェント名
- `prompt`: 次のエージェントに送信するプロンプト
- `send`: `true` の場合、自動的にプロンプトを送信（デフォルトは `false`）

## レビューの必須化

すべての主要工程でレビューを実施します：
- ドキュメント: ISO29148/IEEE1016基準
- テスト: ISTQB基準
- 開発: 言語ベストプラクティス + OWASP
