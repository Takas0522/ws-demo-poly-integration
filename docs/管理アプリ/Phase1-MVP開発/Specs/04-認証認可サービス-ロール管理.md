# 仕様書: 認証認可サービス - ロール管理

**バージョン**: 1.0.0  
**ドキュメントID**: SPEC-AUTH-ROLE-001  
**作成日**: 2026-02-01  
**ステータス**: Draft

## 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|----------|------|---------|--------|
| 1.0.0 | 2026-02-01 | 初版作成 | システム |

---

## 1. 概要

### 1.1 目的とビジネス価値

認証認可サービスにロール管理機能を追加し、**サービス横断的なロールベースアクセス制御（RBAC）を実現**します。

#### ビジネス価値
- **権限管理の自動化**: ユーザーへのロール割り当てをGUIで管理可能
- **セキュリティ強化**: きめ細かなアクセス制御により、誤操作や不正アクセスを防止
- **運用効率化**: ロール単位での権限管理により、ユーザー管理コストを50%削減
- **監査証跡の確保**: すべてのロール割り当て・削除操作を記録
- **マルチサービス対応**: 複数サービスのロールを統合管理

### 1.2 スコープ

**Phase 1 に含まれる機能**:
- ✅ ロール割り当てAPI（作成・削除）
- ✅ 利用可能ロール一覧取得API
- ✅ RoleAssignmentデータモデル
- ✅ JWT生成時のロール情報追加
- ✅ ロールベース認可の完全実装（`require_role`デコレータの有効化）
- ✅ ユーザーロール一覧取得API

**Phase 2 以降の機能**:
- ⏭ ロール階層管理（親子関係）
- ⏭ カスタムロール作成
- ⏭ 動的権限管理
- ⏭ ロール有効期限設定

### 1.3 前提条件

- タスク03「認証認可サービス - コアAPI」が完了
- 現在、JWT内の`roles`フィールドは空配列
- 共通ライブラリの`require_role`デコレータは実装済みだが、Phase 1では権限チェックなし

---

## 2. 用語定義

### 2.1 ロール

サービスごとに定義された権限のセット。ユーザーに割り当てることで、特定の操作を許可します。

**例**:
- `auth-service: 全体管理者` - ユーザーCRUD、ロール割り当て
- `tenant-management: 管理者` - テナントCRUD
- `auth-service: 閲覧者` - ユーザー情報参照のみ

### 2.2 RoleAssignment

ユーザーとロールの紐付け。どのユーザーが、どのサービスの、どのロールを持っているかを示します。

### 2.3 サービス横断ロール管理

各サービスが独自のロールセットを定義し、認証認可サービスがそれらを統合管理する仕組み。

---

## 3. ビジネス要件

### 3.1 ロール割り当て要件

| 要件ID | 要件名 | 説明 | 優先度 |
|-------|--------|------|--------|
| BR-ROLE-001 | ロール割り当て | 全体管理者がユーザーにロールを割り当て可能 | 高 |
| BR-ROLE-002 | ロール削除 | 全体管理者がユーザーからロールを削除可能 | 高 |
| BR-ROLE-003 | ユーザーロール一覧 | ユーザーが持つロールの一覧を取得可能 | 高 |
| BR-ROLE-004 | 利用可能ロール一覧 | テナントが利用可能な全ロールを取得可能 | 高 |
| BR-ROLE-005 | 重複割り当て防止 | 同じロールを重複して割り当てない | 高 |
| BR-ROLE-006 | テナント分離 | 他テナントのユーザーにロールを割り当てない | 高 |

### 3.2 JWT統合要件

| 要件ID | 要件名 | 説明 | 優先度 |
|-------|--------|------|--------|
| BR-JWT-001 | ロール情報含有 | JWT生成時にユーザーのロール情報を含める | 高 |
| BR-JWT-002 | ロール情報形式 | `roles: [{service_id, role_name}]` 形式 | 高 |
| BR-JWT-003 | JWT検証 | JWT検証時にロール情報を返却 | 高 |

### 3.3 認可要件

| 要件ID | 要件名 | 説明 | 優先度 |
|-------|--------|------|--------|
| BR-AUTHZ-001 | ロールベース認可 | `require_role`デコレータでロール確認 | 高 |
| BR-AUTHZ-002 | 権限不足時のエラー | ロールがない場合は403エラー | 高 |
| BR-AUTHZ-003 | 複数ロール対応 | いずれかのロールを持っていれば許可 | 中 |

### 3.4 セキュリティ要件

| 要件ID | 要件名 | 説明 | 優先度 |
|-------|--------|------|--------|
| BR-SEC-001 | 全体管理者のみ | ロール割り当て・削除は全体管理者のみ | 高 |
| BR-SEC-002 | 監査ログ | すべてのロール操作を記録 | 高 |
| BR-SEC-003 | テナント分離強制 | 特権テナント以外は自テナントのみ | 高 |

---

## 4. 機能仕様

### 4.1 データモデル

#### 4.1.1 RoleAssignment モデル

```python
class RoleAssignment(BaseModel):
    id: str                     # role_assignment_{UUID}
    user_id: str                # ユーザーID
    tenant_id: str              # テナントID（パーティションキー）
    type: str = "role_assignment"  # Cosmos DB識別子
    service_id: str             # サービスID (例: "auth-service", "tenant-management")
    role_name: str              # ロール名 (例: "全体管理者", "管理者", "閲覧者")
    assigned_at: datetime       # 割り当て日時
    assigned_by: str            # 割り当てを行ったユーザーID
    created_at: datetime        # 作成日時
```

**Cosmos DB格納例**:
```json
{
  "id": "role_assignment_123e4567-e89b-12d3-a456-426614174000",
  "tenantId": "tenant-acme",
  "type": "role_assignment",
  "userId": "user_456e7890...",
  "serviceId": "auth-service",
  "roleName": "全体管理者",
  "assignedAt": "2026-02-01T10:00:00Z",
  "assignedBy": "user_admin...",
  "createdAt": "2026-02-01T10:00:00Z"
}
```

#### 4.1.2 Role モデル（参照用）

```python
class Role(BaseModel):
    service_id: str
    role_name: str
    description: str
```

### 4.2 ロール管理API仕様

#### 4.2.1 GET /api/v1/roles - 利用可能ロール一覧取得

**リクエスト**:
```http
GET /api/v1/roles
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**レスポンス** (200 OK):
```json
{
  "data": [
    {
      "serviceId": "auth-service",
      "roleName": "全体管理者",
      "description": "ユーザー登録・削除、ロール割り当て"
    },
    {
      "serviceId": "auth-service",
      "roleName": "閲覧者",
      "description": "ユーザー情報の参照のみ"
    },
    {
      "serviceId": "tenant-management",
      "roleName": "管理者",
      "description": "テナントのCRUD操作"
    }
  ]
}
```

**ビジネスロジック**:
1. 現在のユーザーのテナントIDを取得
2. Phase 1では、ハードコードされたロール定義を返却
3. Phase 2では、各サービスの`/api/roles`エンドポイントを呼び出して統合

**パフォーマンス要件**: < 200ms (P95)

#### 4.2.2 GET /api/v1/users/{user_id}/roles - ユーザーロール一覧取得

**認可**: 閲覧者以上

**パスパラメータ**:
- `user_id` (required): ユーザーID

**クエリパラメータ**:
- `tenant_id` (required): テナントID

**レスポンス** (200 OK):
```json
{
  "data": [
    {
      "id": "role_assignment_123e4567...",
      "userId": "user_456e7890...",
      "serviceId": "auth-service",
      "roleName": "全体管理者",
      "assignedAt": "2026-02-01T10:00:00Z",
      "assignedBy": "user_admin..."
    }
  ]
}
```

**ビジネスロジック**:
1. ユーザーの存在確認
2. テナント分離チェック（特権テナント以外は自テナントのみ）
3. Cosmos DBから該当ユーザーのRoleAssignmentを検索

#### 4.2.3 POST /api/v1/users/{user_id}/roles - ロール割り当て

**認可**: 全体管理者

**パスパラメータ**:
- `user_id` (required): ユーザーID

**リクエスト**:
```json
{
  "tenantId": "tenant-acme",
  "serviceId": "tenant-management",
  "roleName": "管理者"
}
```

**レスポンス** (201 Created):
```json
{
  "id": "role_assignment_abc123...",
  "userId": "user_456e7890...",
  "tenantId": "tenant-acme",
  "serviceId": "tenant-management",
  "roleName": "管理者",
  "assignedAt": "2026-02-01T11:00:00Z",
  "assignedBy": "user_admin..."
}
```

**エラーレスポンス**:
- `404 Not Found`: ユーザーが存在しない
- `409 Conflict`: 同じロールが既に割り当て済み
- `403 Forbidden`: テナント分離違反、または権限不足

**バリデーション**:
- ユーザーの存在確認
- サービスIDとロール名の妥当性確認
- 重複チェック
- テナント分離チェック

**ビジネスロジック**:
1. ユーザーの存在確認
2. 重複チェック（同じservice_id + role_nameの組み合わせ）
3. RoleAssignmentオブジェクト作成
4. Cosmos DBに保存
5. 監査ログ記録（assigned_by に現在のユーザーID）

#### 4.2.4 DELETE /api/v1/users/{user_id}/roles/{role_assignment_id} - ロール削除

**認可**: 全体管理者

**パスパラメータ**:
- `user_id` (required): ユーザーID
- `role_assignment_id` (required): ロール割り当てID

**クエリパラメータ**:
- `tenant_id` (required): テナントID

**レスポンス** (204 No Content):
（レスポンスボディなし）

**ビジネスロジック**:
1. RoleAssignmentの存在確認
2. ユーザーIDの一致確認
3. テナント分離チェック
4. Cosmos DBから削除
5. 監査ログ記録（deleted_by に現在のユーザーID）

### 4.3 JWT生成の変更

#### 4.3.1 既存のJWT生成（タスク03）

```python
# タスク03の実装
payload = {
    "sub": user.id,
    "username": user.username,
    "tenant_id": user.tenant_id,
    "roles": [],  # 空配列
    "exp": expire,
    "iat": datetime.utcnow(),
    "jti": jwt_id
}
```

#### 4.3.2 タスク04での変更

```python
# タスク04での改善
async def create_token(self, user: User) -> TokenData:
    # 1. ユーザーのロール情報を取得
    role_assignments = await self.role_repository.get_by_user_id(user.id, user.tenant_id)
    
    # 2. ロール情報を整形
    roles = [
        {"service_id": ra.service_id, "role_name": ra.role_name}
        for ra in role_assignments
    ]
    
    # 3. JWTペイロード作成
    payload = {
        "sub": user.id,
        "username": user.username,
        "tenant_id": user.tenant_id,
        "roles": roles,  # ロール情報を含める
        "exp": expire,
        "iat": datetime.utcnow(),
        "jti": jwt_id
    }
    
    return create_access_token(payload)
```

### 4.4 ロールベース認可の有効化

#### 4.4.1 共通ライブラリの`require_role`デコレータ（タスク02実装済み）

```python
# common/auth/dependencies.py
def require_role(service_id: str, role_name: str):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # request.state.user からユーザー情報取得
            user = request.state.user
            
            # タスク04で有効化: ロールチェック
            if not user.has_role(service_id, role_name):
                raise HTTPException(
                    status_code=403,
                    detail=f"Role '{role_name}' in service '{service_id}' is required"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

#### 4.4.2 has_role メソッドの実装

```python
# app/models/user.py
class User(BaseModel):
    # ... existing fields ...
    roles: List[Dict[str, str]] = []  # JWTから取得
    
    def has_role(self, service_id: str, role_name: str) -> bool:
        """指定されたロールを持っているかチェック"""
        return any(
            role["service_id"] == service_id and role["role_name"] == role_name
            for role in self.roles
        )
```

---

## 5. 非機能要件

### 5.1 パフォーマンス

| 項目 | 目標値 | 測定方法 | 測定条件 |
|------|--------|---------|---------|
| ロール一覧取得 | < 200ms (P95) | Application Insights | 30日間のデータ、通常負荷時 |
| ロール割り当て | < 300ms (P95) | Application Insights | 30日間のデータ、通常負荷時 |
| ロール削除 | < 200ms (P95) | Application Insights | 30日間のデータ、通常負荷時 |
| **JWT生成（ロール情報含む）** | **< 100ms (P95)** | Application Insights | ロール数≤10件の場合 |

**パフォーマンス最適化**:

1. **ロール情報のキャッシュ（Phase 2）**
   - RedisにユーザーIDをキーにロール情報をキャッシュ
   - TTL: 60分（JWTの有効期限と同じ）
   - ロール変更時にキャッシュを無効化

2. **Phase 1の実装**
   ```python
   # app/services/auth_service.py
   async def create_token(self, user: User) -> TokenData:
       # ロール情報取得（Cosmos DBクエリ）
       # - partition_keyを指定して効率化
       # - user_idでインデックス検索
       role_assignments = await self.role_repository.get_by_user_id(
           user.id, 
           user.tenant_id  # partition_key指定
       )
       
       # 最大ロール数の制限（パフォーマンス保証）
       if len(role_assignments) > 20:
           logger.warning(f"User has too many roles: user_id={user.id}, count={len(role_assignments)}")
           role_assignments = role_assignments[:20]  # 上位20件のみ
       
       # JWT生成
       ...
   ```

3. **パフォーマンス監視**
   - Application Insightsで各APIの応答時間を監視
   - P95が目標値を超えた場合、アラートを発信
   - 週次レビューでパフォーマンストレンドを確認

### 5.2 セキュリティ

| 要件 | 実装方法 |
|------|---------|
| 認可チェック | 全体管理者のみロール操作可能 |
| テナント分離 | BaseRepositoryの3層チェック + アプリケーション層チェック |
| 監査ログ | 全ロール操作（割り当て・削除）を記録 |
| JWT署名 | HS256、環境変数の秘密鍵 |

### 5.3 データ整合性

#### 5.3.1 カスケード削除の実装

**課題**: Cosmos DBはトランザクショナルなカスケード削除をネイティブにサポートしない

**Phase 1の実装方法**:

```python
# app/services/user_service.py
async def delete_user(self, user_id: str, tenant_id: str, deleted_by: str) -> None:
    """ユーザー削除（論理削除）"""
    # 1. ユーザー取得
    user = await self.user_repository.get(user_id, tenant_id)
    
    # 2. is_activeをFalseに設定（論理削除）
    user.is_active = False
    user.updated_at = datetime.utcnow()
    user.updated_by = deleted_by
    await self.user_repository.update(user_id, tenant_id, user.model_dump())
    
    # 3. 関連RoleAssignmentの論理削除
    role_assignments = await self.role_repository.get_by_user_id(user_id, tenant_id)
    for ra in role_assignments:
        await self.role_repository.delete(ra.id, tenant_id)
    
    # 4. 監査ログ記録
    logger.info(f"User deleted (logical): user_id={user_id}, deleted_by={deleted_by}")
```

**Phase 2の改善**:
- Cosmos DBのChange Feedを使用し、ユーザー削除イベントを検知し、非同期でRoleAssignmentを削除
- または、is_deletedフラグで管理し、定期的なバッチ処理で物理削除

**整合性保証**:
- 論理削除により、物理データは保持され監査証跡を確保
- ロール割り当て時に is_active チェックを実施

#### 5.3.2 重複ロール割り当ての防止

**課題**: 同時実行時の競合状態（Race Condition）

**実装方法**:

```python
# app/repositories/role_repository.py
async def create_if_not_exists(
    self,
    user_id: str,
    tenant_id: str,
    service_id: str,
    role_name: str,
    assigned_by: str
) -> Tuple[RoleAssignment, bool]:
    """
    重複チェック付きでロール割り当てを作成
    
    Returns:
        (RoleAssignment, created): created=Trueなら新規作成、Falseなら既存
    """
    # 1. 先に存在チェック
    existing = await self.find_by_user_and_service(
        user_id, tenant_id, service_id, role_name
    )
    if existing:
        return existing, False
    
    # 2. 一意IDを使用して作成（Cosmos DBのidが一意制約）
    role_assignment = RoleAssignment(
        id=f"ra_{user_id}_{service_id}_{role_name}",  # 決定的ID
        user_id=user_id,
        tenant_id=tenant_id,
        service_id=service_id,
        role_name=role_name,
        assigned_by=assigned_by,
        assigned_at=datetime.utcnow()
    )
    
    try:
        await self.create(role_assignment)
        return role_assignment, True
    except CosmosHttpResponseError as e:
        if e.status_code == 409:  # Conflict: ID重複
            # 再度取得して返却
            existing = await self.get(role_assignment.id, tenant_id)
            return existing, False
        raise
```

**決定的IDの使用**:
- IDフォーマット: `ra_{user_id}_{service_id}_{role_name}`
- Cosmos DBのidフィールドの一意制約を活用
- 409 Conflictエラーをキャッチし、既存レコードを返却

#### 5.3.3 データ整合性検証

**定期的な整合性チェック（Phase 2）**:
```python
# 孤立RoleAssignmentの検出（ユーザーが存在しない）
# 非アクティブユーザーのRoleAssignmentクリーンアップ
```

---

## 6. エラーコード一覧

### 6.1 ロール管理エラー

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|-----------|--------|
| ROLE_001_USER_NOT_FOUND | 404 | User not found | ユーザーID不存在 |
| ROLE_002_DUPLICATE_ASSIGNMENT | 409 | Role already assigned to this user | 重複ロール割り当て |
| ROLE_003_ASSIGNMENT_NOT_FOUND | 404 | Role assignment not found | ロール割り当てID不存在 |
| ROLE_004_INVALID_SERVICE | 400 | Invalid service ID | サービスID不正 |
| ROLE_005_INVALID_ROLE | 400 | Invalid role name for this service | ロール名不正 |
| ROLE_006_TENANT_ISOLATION_VIOLATION | 403 | Cannot assign role to user in different tenant | テナント分離違反 |

### 6.2 認可エラー

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|-----------|--------|
| AUTHZ_001_INSUFFICIENT_ROLE | 403 | Role required: {service_id}:{role_name} | ロール不足 |
| AUTHZ_002_PERMISSION_DENIED | 403 | Permission denied | 一般的な権限不足 |

---

## 7. テスト要件

### 7.1 単体テスト

#### 7.1.1 Repository テスト
- RoleAssignmentRepository CRUD操作
- ユーザーID検索
- 重複チェック
- テナント内一覧取得

#### 7.1.2 Service テスト
- RoleService: ロール割り当て、削除、バリデーション
- AuthService: JWT生成時のロール情報追加

#### 7.1.3 API テスト
- ロール管理API: GET /roles, GET/POST/DELETE /users/{userId}/roles
- 権限チェック: require_roleデコレータの動作確認

### 7.2 統合テスト

- ロール割り当てからJWT生成までのフロー
- ロールベース認可の動作確認
- テナント分離の検証

### 7.3 セキュリティテスト

| テストケース | 期待結果 |
|------------|---------|
| 閲覧者でロール割り当て | 403エラー |
| 他テナントのユーザーにロール割り当て | 403エラー |
| 重複ロール割り当て | 409エラー |
| ロールなしでrequire_role保護されたAPI呼び出し | 403エラー |

### 7.4 カバレッジ目標

- **行カバレッジ**: 75%以上
- **分岐カバレッジ**: 70%以上
- **関数カバレッジ**: 80%以上

---

## 8. 依存関係

### 8.1 共通ライブラリ依存

| モジュール | 使用関数/クラス | 用途 |
|----------|--------------|------|
| common.auth.dependencies | get_current_user, require_role | 認証・認可 |
| common.database.repository | BaseRepository | CRUD操作 |
| common.auth.jwt | create_access_token, decode_access_token | JWT生成・検証 |

### 8.2 既存コンポーネント依存

| コンポーネント | 依存内容 |
|------------|--------|
| UserRepository | ユーザーの存在確認 |
| AuthService | JWT生成時のロール情報追加 |

---

## 9. 制約事項

### 9.1 技術的制約

- Python 3.11+
- FastAPI 0.100+
- Cosmos DB パーティション設計に準拠

### 9.2 実装上の制約

- Phase 1では、ロール定義はハードコード（サービスID + ロール名）
- ロール階層管理は Phase 2
- カスタムロール作成は Phase 2

### 9.3 運用上の制約

- ロール割り当て変更後、既存JWTは有効期限まで古いロール情報を保持
- ユーザー削除時、RoleAssignmentも削除される（カスケード削除）

---

## 10. 受け入れ基準

### 10.1 機能的受け入れ基準

- [ ] 全APIエンドポイントが実装され、動作する
- [ ] GET /api/v1/roles: 利用可能ロール一覧取得
- [ ] GET /api/v1/users/{userId}/roles: ユーザーロール一覧取得
- [ ] POST /api/v1/users/{userId}/roles: ロール割り当て
- [ ] DELETE /api/v1/users/{userId}/roles/{roleId}: ロール削除
- [ ] JWT生成時にロール情報が含まれる
- [ ] `require_role`デコレータがロールチェックを実行する
- [ ] テナント分離が強制される

### 10.2 非機能的受け入れ基準

- [ ] パフォーマンス目標達成
- [ ] セキュリティ要件達成（全体管理者のみ、監査ログ）
- [ ] テストカバレッジ 75%以上
- [ ] 全テストが合格

### 10.3 運用的受け入れ基準

- [ ] ローカル環境で起動・動作確認
- [ ] README.md更新（ロール管理機能の追加）
- [ ] OpenAPI仕様書が更新される (/docs)

---

## 11. リスク分析

| リスク | 影響度 | 発生確率 | 緩和策 |
|-------|--------|---------|--------|
| JWT肥大化 | 中 | 中 | ロール数を制限、Phase 2でロール情報圧縮検討 |
| 既存JWTとの互換性 | 低 | 低 | 空配列から実データへの移行は後方互換 |
| ロール定義の不整合 | 中 | 中 | Phase 1ではハードコード、Phase 2で各サービスから取得 |
| カスケード削除の誤動作 | 高 | 低 | 十分なテストで検証、監査ログで追跡可能 |

---

## 12. 成功の定義

### 12.1 短期（Phase 1）

- 全ての受け入れ基準を満たす
- ロールベース認可が完全に動作
- タスク05（テナント管理サービス）がロール機能を使用して実装可能
- テストカバレッジ 75%以上

### 12.2 長期（Phase 2以降）

- ロール管理起因のインシデント月1件以下
- ロール割り当て操作の成功率 99%以上
- ユーザー管理コスト50%削減

---

## 13. 参照ドキュメント

- [コンポーネント設計 - 認証認可サービス](../../arch/components/README.md#3-認証認可サービス)
- [API設計 - ロール管理エンドポイント](../../arch/api/README.md#34-ロール管理エンドポイント)
- [データモデル設計 - RoleAssignment](../../arch/data/README.md#22-roleassignment-エンティティ)
- [セキュリティ設計 - 認可](../../arch/security/README.md#3-認可-authorization)
- [タスク03 - 認証認可サービス - コアAPI](./03-認証認可サービス-コアAPI.md)

---

## 14. 付録

### 14.1 ロール定義（Phase 1ハードコード）

#### 認証認可サービス
```python
AUTH_SERVICE_ROLES = [
    {"service_id": "auth-service", "role_name": "全体管理者", "description": "ユーザーCRUD、ロール割り当て"},
    {"service_id": "auth-service", "role_name": "閲覧者", "description": "ユーザー情報参照のみ"}
]
```

#### テナント管理サービス（タスク05で定義予定）
```python
TENANT_SERVICE_ROLES = [
    {"service_id": "tenant-management", "role_name": "管理者", "description": "テナントCRUD"},
    {"service_id": "tenant-management", "role_name": "閲覧者", "description": "テナント情報参照のみ"}
]
```

### 14.2 JWTペイロード例（タスク04後）

```json
{
  "sub": "user_123e4567-e89b-12d3-a456-426614174000",
  "username": "john.doe",
  "tenant_id": "tenant-acme",
  "roles": [
    {"service_id": "auth-service", "role_name": "全体管理者"},
    {"service_id": "tenant-management", "role_name": "管理者"}
  ],
  "exp": 1738412400,
  "iat": 1738408800,
  "jti": "jwt_456e7890-ab12-34cd-ef56-789012345678"
}
```

---

**ドキュメント終了**
