````markdown
# 機能仕様書: テナント管理サービス - ユーザー・ドメイン管理

**バージョン**: 1.0.0  
**ドキュメントID**: SPEC-TENANT-002  
**作成日**: 2026-02-01  
**ステータス**: Draft

## 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|----------|------|---------|--------|
| 1.0.0 | 2026-02-01 | 初版作成 | システム |

---

## 1. はじめに

### 1.1 目的

本仕様書は、マルチテナント管理アプリケーションにおける**テナント管理サービス - ユーザー・ドメイン管理**の機能要件と非機能要件を定義します。タスク05で実装したテナントCRUD機能を基盤として、テナントへのユーザー招待機能と独自ドメイン管理機能を追加します。

### 1.2 スコープ

#### 本タスクに含まれる機能

- ✅ TenantUser管理（テナントへのユーザー招待・削除）
- ✅ テナント所属ユーザー一覧取得
- ✅ Domain管理（独自ドメインの追加・削除・検証）
- ✅ ドメイン検証フロー（DNS TXTレコード検証）
- ✅ user_countの自動更新（TenantUser作成・削除時）
- ✅ ロールベース認可（管理者、全体管理者）

#### 本タスクに含まれない機能

- ⏭ ユーザー作成機能（認証認可サービスで実装済み）
- ⏭ ドメインベースのメールアドレス制限（Phase 2）
- ⏭ ユーザー招待メール送信（Phase 2）
- ⏭ TenantUserへのロール割り当て（Phase 2）

### 1.3 用語定義

| 用語 | 定義 |
|------|------|
| TenantUser | テナントとユーザーの関連を表すエンティティ。ユーザーはテナントに所属することで、そのテナントのリソースにアクセス可能となる |
| ユーザー招待 | 既存のユーザー（認証認可サービスで管理）をテナントに追加すること |
| Domain | テナントが所有する独自ドメイン（例: example.com）。検証後、そのドメインのメールアドレスを持つユーザーのみを招待可能にする（Phase 2） |
| ドメイン検証 (Domain Verification) | DNS TXTレコードを使用して、ドメインの所有権を確認するプロセス |
| 検証トークン (Verification Token) | ドメイン検証用にシステムが生成するランダム文字列 |

---

## 2. ビジネス要件

### 2.1 ビジネス目標

本機能は、以下のビジネス目標を達成します：

1. **ユーザー管理の効率化**: テナント管理者が自テナントのユーザーを管理できるようにし、全体管理者の負担を50%削減
2. **セキュリティ強化**: 独自ドメイン検証により、信頼できるドメインのユーザーのみを招待可能にする
3. **スケーラビリティ**: ユーザー招待プロセスを5分以内で完了
4. **データ整合性**: user_countの自動更新により、手動管理のエラーをゼロに
5. **監査証跡の確保**: 全てのユーザー招待・削除を記録し、コンプライアンス要件を満たす

### 2.2 ユーザーストーリー

#### US-TENANT-USER-001: テナントへのユーザー招待
**As a** 管理者  
**I want** 既存ユーザーを自テナントに招待したい  
**So that** 新しいメンバーにシステムアクセスを付与できる

**受入条件**:
- [ ] 認証認可サービスに存在するユーザーIDを指定して招待
- [ ] 同一ユーザーの重複招待は防止される
- [ ] 最大ユーザー数（max_users）を超える招待は拒否される
- [ ] user_countが自動的にインクリメントされる
- [ ] 招待者と招待日時が記録される

#### US-TENANT-USER-002: テナント所属ユーザー一覧の参照
**As a** 閲覧者  
**I want** 自テナントに所属するユーザー一覧を参照したい  
**So that** チームメンバーを把握できる

**受入条件**:
- [ ] テナントに招待されたユーザーの一覧が表示される
- [ ] ユーザー名、招待日時、招待者が確認できる
- [ ] ページネーション機能がある（最大100件/ページ）

#### US-TENANT-USER-003: テナントからのユーザー削除
**As a** 管理者  
**I want** テナントからユーザーを削除したい  
**So that** 退職者や権限を剥奪したいユーザーのアクセスを無効化できる

**受入条件**:
- [ ] TenantUserが削除される（ユーザー本体は削除されない）
- [ ] user_countが自動的にデクリメントされる
- [ ] 削除者が記録される（Application Insights）

#### US-TENANT-DOMAIN-001: 独自ドメインの追加
**As a** 管理者  
**I want** 自社ドメインをテナントに登録したい  
**So that** 自社メールアドレスを持つユーザーのみを招待できるようにする

**受入条件**:
- [ ] ドメイン名を指定してドメインを追加
- [ ] 検証トークンが生成される
- [ ] DNS TXTレコードの設定手順が提示される

#### US-TENANT-DOMAIN-002: ドメイン所有権の検証
**As a** 管理者  
**I want** 登録したドメインを検証したい  
**So that** ドメインの所有権を証明できる

**受入条件**:
- [ ] DNS TXTレコードを確認して所有権を検証
- [ ] 検証成功時に`verified=true`に更新
- [ ] 検証失敗時にエラーメッセージを表示

#### US-TENANT-DOMAIN-003: 登録ドメインの削除
**As a** 管理者  
**I want** 登録したドメインを削除したい  
**So that** 不要になったドメインを管理対象から除外できる

**受入条件**:
- [ ] Domainが物理削除される
- [ ] 削除者が記録される（Application Insights）

### 2.3 ビジネスルール

| ルールID | ルール名 | 説明 | 優先度 |
|---------|--------|------|--------|
| BR-TENANT-USER-001 | 重複招待の防止 | 同一テナント内で同一ユーザーは複数回招待できない | 高 |
| BR-TENANT-USER-002 | 最大ユーザー数制限 | テナントの`max_users`を超えるユーザー招待は拒否される | 高 |
| BR-TENANT-USER-003 | user_count自動更新 | TenantUser作成時にインクリメント、削除時にデクリメント | 高 |
| BR-TENANT-USER-004 | ユーザー存在チェック | 招待時に認証認可サービスでユーザーの存在を確認 | 高 |
| BR-TENANT-DOMAIN-001 | ドメイン一意性 | 同一ドメインは複数のテナントに登録できる（所有権検証が前提） | 中 |
| BR-TENANT-DOMAIN-002 | DNS検証必須 | ドメインは検証完了後に`verified=true`となる | 高 |
| BR-TENANT-DOMAIN-003 | 検証トークン形式 | `txt-verification-{ランダム文字列32桁}`形式 | 中 |

---

## 3. 機能要件

### 3.1 機能概要

本タスクでは、以下の機能を提供します：

1. **TenantUser管理**: テナントへのユーザー招待、所属ユーザー一覧取得、ユーザー削除
2. **Domain管理**: 独自ドメインの追加、ドメイン検証、ドメイン削除、ドメイン一覧取得

### 3.2 機能詳細

#### 3.2.1 テナントへのユーザー招待

- **説明**: 既存のユーザーをテナントに招待します。管理者ロールが必要です。
- **入力**: 
  - パスパラメータ: `tenant_id`
  - リクエストボディ:
    - `user_id` (required): 招待するユーザーのID
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 管理者）
  2. テナント存在確認
  3. **ユーザー存在確認（認証認可サービスに問い合わせ）**
     - **エンドポイント**: `GET {AUTH_SERVICE_URL}/api/v1/users/{user_id}`
     - **認証方式**: サービス間API Key（`X-Service-Key`ヘッダー）
     - **タイムアウト**: 2秒
     - **リトライ**: 最大2回、指数バックオフ（100ms, 200ms）
     - **エラーハンドリング**:
       - 404: ユーザーが存在しない → HTTPException(404, "User not found")
       - 503/タイムアウト: 認証認可サービスダウン → HTTPException(503, "User verification service unavailable")
       - 401: API Key無効 → HTTPException(500, "Service authentication failed")
  4. 重複チェック
     - Cosmos DBクエリ: `SELECT * FROM c WHERE c.tenant_id = @tenant_id AND c.type = 'tenant_user' AND c.user_id = @user_id`
     - 既に存在する場合は409エラー
  5. 最大ユーザー数チェック
     - `tenant.user_count >= tenant.max_users`の場合は400エラー
  6. TenantUserオブジェクト作成
     - `id`は決定的ID: `tenant_user_{tenant_id}_{user_id}`
     - `assigned_by`に現在のユーザーID
     - `assigned_at`に現在時刻
  7. Cosmos DBに保存
  8. TenantServiceの`increment_user_count(tenant_id)`を呼び出し（詳細は後述）
  9. 監査ログ記録
- **出力**: 作成されたTenantUser情報（JSON）

**Cosmos DBクエリ例（重複チェック）**:
```sql
SELECT * FROM c 
WHERE c.tenant_id = @tenant_id 
  AND c.type = 'tenant_user' 
  AND c.user_id = @user_id
```

**認証認可サービス連携の実装**:
```python
import httpx
import os
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=0.1, min=0.1, max=1),
    reraise=True
)
async def verify_user_exists(user_id: str) -> bool:
    """
    認証認可サービスでユーザーの存在を確認
    
    Args:
        user_id: 検証するユーザーID
    
    Returns:
        bool: ユーザーが存在する場合True
    
    Raises:
        HTTPException(404): ユーザーが存在しない
        HTTPException(503): 認証認可サービスが利用不可
        HTTPException(500): サービス間認証失敗
    
    Retry Policy:
        - 最大3回リトライ
        - 指数バックオフ（100ms, 200ms, 400ms）
        - タイムアウト: 2秒
        - リトライ対象: 503, 504, タイムアウト、ネットワークエラー
        - リトライ除外: 404, 401（即座にエラー）
    """
    auth_service_url = os.getenv("AUTH_SERVICE_URL", "http://auth-service:8000")
    api_key = os.getenv("SERVICE_API_KEY")
    
    if not api_key:
        raise HTTPException(
            status_code=500,
            detail="Service API key not configured"
        )
    
    try:
        async with httpx.AsyncClient(timeout=2.0) as client:
            response = await client.get(
                f"{auth_service_url}/api/v1/users/{user_id}",
                headers={
                    "X-Service-Key": api_key,
                    "X-Requesting-Service": "tenant-management"
                }
            )
            
            if response.status_code == 404:
                raise HTTPException(
                    status_code=404,
                    detail="User not found in authentication service"
                )
            elif response.status_code == 401:
                raise HTTPException(
                    status_code=500,
                    detail="Service authentication failed"
                )
            elif response.status_code >= 500:
                # 5xxエラーはリトライ対象
                raise httpx.HTTPStatusError(
                    f"Auth service error: {response.status_code}",
                    request=response.request,
                    response=response
                )
            
            response.raise_for_status()
            return True
            
    except httpx.TimeoutException:
        logger.warning(f"Timeout verifying user {user_id}")
        raise HTTPException(
            status_code=503,
            detail="User verification service timeout"
        )
    except httpx.NetworkError as e:
        logger.error(f"Network error verifying user {user_id}: {e}")
        raise HTTPException(
            status_code=503,
            detail="User verification service unavailable"
        )
```

#### 3.2.2 テナント所属ユーザー一覧取得

- **説明**: テナントに所属するユーザーの一覧を取得します。
- **入力**: 
  - パスパラメータ: `tenant_id`
  - クエリパラメータ: `skip`（ページネーション）、`limit`（最大100件）
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 閲覧者以上）
  2. テナント分離チェック（特権テナント以外は自テナントのみ）
  3. Cosmos DBから該当テナントのTenantUserを取得
  4. `skip`と`limit`でページネーション
  5. **totalカウント取得**（totalが必要な場合のみ）
     - 別クエリで `SELECT VALUE COUNT(1) FROM c WHERE c.tenant_id = @tenant_id AND c.type = 'tenant_user'`
     - クエリパラメータ `include_total=true` 時のみ実行（パフォーマンス考慮）
  6. 各TenantUserに対して、認証認可サービスからユーザー詳細情報を取得（並列処理）
     - `asyncio.gather` で最大10件同時取得
     - 取得失敗時は該当ユーザーをスキップ（部分的失敗を許容）
- **出力**: TenantUser一覧（JSON配列）

**Cosmos DBクエリ例**:
```sql
-- ページネーション用クエリ
SELECT * FROM c 
WHERE c.tenant_id = @tenant_id 
  AND c.type = 'tenant_user'
ORDER BY c.assigned_at DESC
OFFSET @skip LIMIT @limit

-- totalカウント取得（include_total=true時のみ）
SELECT VALUE COUNT(1) FROM c 
WHERE c.tenant_id = @tenant_id 
  AND c.type = 'tenant_user'
```

**並列ユーザー情報取得の実装**:
```python
import asyncio
import httpx
from typing import List, Optional

async def get_user_details(user_id: str, service_token: str) -> Optional[dict]:
    """
    認証認可サービスからユーザー詳細を取得
    
    Timeout: 2秒
    Retry: 最大2回、指数バックオフ（100ms, 200ms）
    Fallback: 失敗時はNoneを返却（部分的失敗を許容）
    """
    try:
        async with httpx.AsyncClient(timeout=2.0) as client:
            response = await client.get(
                f"{AUTH_SERVICE_URL}/api/v1/users/{user_id}",
                headers={"X-Service-Key": os.getenv("SERVICE_API_KEY")}
            )
            response.raise_for_status()
            return response.json()
    except (httpx.TimeoutException, httpx.HTTPError) as e:
        logger.warning(f"Failed to fetch user details for {user_id}: {e}")
        return None

async def get_tenant_users_with_details(
    tenant_users: List[TenantUser],
    service_token: str
) -> List[dict]:
    """
    複数ユーザーの詳細情報を並列取得
    
    Parallelism: 最大10件同時
    """
    # 並列取得（最大10件同時）
    tasks = [
        get_user_details(tu.user_id, service_token) 
        for tu in tenant_users
    ]
    user_details_list = await asyncio.gather(*tasks, return_exceptions=False)
    
    # 結果をマージ（取得失敗したユーザーは基本情報のみ）
    results = []
    for tenant_user, user_details in zip(tenant_users, user_details_list):
        result = {
            "id": tenant_user.id,
            "user_id": tenant_user.user_id,
            "assigned_at": tenant_user.assigned_at,
            "assigned_by": tenant_user.assigned_by
        }
        
        if user_details:
            result["user_details"] = user_details
        else:
            # フォールバック: 基本情報のみ
            result["user_details"] = {
                "user_id": tenant_user.user_id,
                "error": "Details unavailable"
            }
        
        results.append(result)
    
    return results
```

#### 3.2.3 テナントからのユーザー削除

- **説明**: テナントからユーザーを削除します（ユーザー本体は削除されません）。
- **入力**: 
  - パスパラメータ: `tenant_id`, `user_id`
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 管理者）
  2. TenantUser存在確認
  3. Cosmos DBから物理削除
  4. TenantServiceの`decrement_user_count(tenant_id)`を呼び出し
  5. 監査ログ記録（`deleted_by`に現在のユーザーID、Application Insightsに記録）
- **出力**: 204 No Content

#### 3.2.4 独自ドメインの追加

- **説明**: テナントに独自ドメインを追加します。
- **入力**: 
  - パスパラメータ: `tenant_id`
  - リクエストボディ:
    - `domain` (required): ドメイン名（例: "example.com"）
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 管理者）
  2. テナント存在確認
  3. ドメイン形式バリデーション（正規表現）
  4. 検証トークン生成
     - `txt-verification-{ランダム文字列32桁}`
  5. Domainオブジェクト作成
     - `id`: `domain_{tenant_id}_{slug化したdomain}`
     - `verified`: `false`
     - `verification_token`: 生成したトークン
     - `created_at`: 現在時刻
     - `created_by`: 現在のユーザーID
  6. Cosmos DBに保存
  7. 監査ログ記録
- **出力**: 作成されたDomain情報とDNS設定手順（JSON）

**検証トークン生成**:
```python
import secrets

def generate_verification_token() -> str:
    """検証トークン生成（32桁のランダム文字列）"""
    random_str = secrets.token_hex(16)  # 32文字
    return f"txt-verification-{random_str}"
```

**DNS設定手順の生成**:
```json
{
  "id": "domain_tenant123_example_com",
  "tenant_id": "tenant_123",
  "domain": "example.com",
  "verified": false,
  "verification_token": "txt-verification-a1b2c3d4...",
  "verification_instructions": {
    "step1": "DNSプロバイダーにログイン",
    "step2": "以下のTXTレコードを追加:",
    "record_name": "_tenant_verification.example.com",
    "record_type": "TXT",
    "record_value": "txt-verification-a1b2c3d4..."
  }
}
```

#### 3.2.5 ドメイン所有権の検証

- **説明**: DNS TXTレコードを確認してドメインの所有権を検証します。
- **入力**: 
  - パスパラメータ: `tenant_id`, `domain_id`
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 管理者）
  2. Domain取得
  3. 既に検証済みの場合はスキップ
  4. **DNS TXTレコードクエリ**
     - `_tenant_verification.{domain}`のTXTレコードを取得
     - Pythonの`dnspython`ライブラリを使用
     - **タイムアウト**: 5秒（DNS問い合わせはネットワーク状況に依存）
     - **リトライ**: 最大3回、固定間隔1秒
     - **対象DNSサーバー**: システムデフォルト（`/etc/resolv.conf`）
       - Phase 2: 複数のDNSサーバー（Google DNS 8.8.8.8、Cloudflare DNS 1.1.1.1）を順次試行
  5. 検証トークンとの一致確認
  6. 一致した場合
     - `verified`: `true`
     - `verified_at`: 現在時刻
     - `verified_by`: 現在のユーザーID
     - Cosmos DBに保存
  7. 不一致の場合
     - 422エラー（`Verification failed: TXT record not found or mismatch`）
  8. 監査ログ記録
- **出力**: 検証結果（JSON）

**DNS検証コード（改善版）**:
```python
import dns.resolver
from typing import Optional
from tenacity import retry, stop_after_attempt, wait_fixed

@retry(
    stop=stop_after_attempt(3),
    wait=wait_fixed(1),
    reraise=True
)
async def verify_domain_ownership(domain: str, expected_token: str) -> bool:
    """
    DNS TXTレコードでドメイン所有権を検証
    
    Args:
        domain: 検証するドメイン（例: "example.com"）
        expected_token: 期待する検証トークン
    
    Returns:
        bool: 検証成功時True、失敗時False
    
    Raises:
        dns.exception.Timeout: DNS問い合わせタイムアウト（5秒超過）
        dns.exception.DNSException: その他のDNSエラー
    
    Retry Policy:
        - 最大3回リトライ
        - 固定間隔1秒
        - DNS伝播の遅延に対応
    
    Timeout:
        - 5秒（DNS問い合わせはネットワーク状況に依存）
    """
    record_name = f"_tenant_verification.{domain}"
    
    try:
        # DNS Resolverの設定
        resolver = dns.resolver.Resolver()
        resolver.timeout = 5.0  # タイムアウト5秒
        resolver.lifetime = 5.0  # 全体のタイムアウト5秒
        
        # Phase 2: 複数のDNSサーバーを試行
        # resolver.nameservers = ['8.8.8.8', '1.1.1.1']  # Google DNS, Cloudflare DNS
        
        # DNS TXTレコードクエリ
        answers = resolver.resolve(record_name, 'TXT')
        
        # 各TXTレコードをチェック
        for rdata in answers:
            for txt_string in rdata.strings:
                txt_value = txt_string.decode('utf-8')
                logger.info(f"Found TXT record: {txt_value}")
                if txt_value == expected_token:
                    return True
        
        logger.warning(f"TXT record found but token mismatch for {domain}")
        return False
        
    except dns.resolver.NXDOMAIN:
        # ドメインが存在しない
        logger.warning(f"Domain does not exist: {domain}")
        return False
    except dns.resolver.NoAnswer:
        # TXTレコードが存在しない
        logger.warning(f"No TXT record found for {record_name}")
        return False
    except dns.exception.Timeout:
        # タイムアウト（リトライ対象）
        logger.warning(f"DNS query timeout for {record_name}")
        raise
    except Exception as e:
        # その他のDNSエラー
        logger.error(f"DNS verification error for {domain}: {e}")
        return False
```

#### 3.2.6 ドメイン一覧取得

- **説明**: テナントに登録されているドメインの一覧を取得します。
- **入力**: 
  - パスパラメータ: `tenant_id`
  - クエリパラメータ: `verified`（オプション、true/false）
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 閲覧者以上）
  2. テナント分離チェック
  3. Cosmos DBから該当テナントのDomainを取得
  4. `verified`フィルタを適用（指定された場合）
- **出力**: Domain一覧（JSON配列）

**Cosmos DBクエリ例**:
```sql
SELECT * FROM c 
WHERE c.tenant_id = @tenant_id 
  AND c.type = 'domain'
  AND c.verified = @verified  -- フィルタ指定時
ORDER BY c.created_at DESC
```

#### 3.2.7 ドメイン削除

- **説明**: 登録済みドメインを削除します。
- **入力**: 
  - パスパラメータ: `tenant_id`, `domain_id`
  - Authorization ヘッダー: JWT
- **処理**:
  1. ロール認可チェック（tenant-management: 管理者）
  2. Domain取得
  3. Cosmos DBから物理削除
  4. 監査ログ記録（`deleted_by`に現在のユーザーID、Application Insightsに記録）
- **出力**: 204 No Content

### 3.3 画面仕様

本タスク（Phase 1）では画面は含まれません。タスク16「Frontend - テナント管理画面」で実装予定です。

### 3.4 API仕様

#### 3.4.1 POST /api/v1/tenants/{tenant_id}/users - ユーザー招待

**認可**: tenant-management: 管理者

**リクエスト**:
```http
POST /api/v1/tenants/tenant_acme/users
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json

{
  "user_id": "user_550e8400-e29b-41d4-a716-446655440000"
}
```

**レスポンス** (201 Created):
```json
{
  "id": "tenant_user_tenant_acme_user_550e8400",
  "tenant_id": "tenant_acme",
  "user_id": "user_550e8400-e29b-41d4-a716-446655440000",
  "user_details": {
    "username": "user@example.com",
    "display_name": "山田太郎",
    "email": "user@example.com"
  },
  "assigned_at": "2026-02-01T10:00:00Z",
  "assigned_by": "user_admin_001"
}
```

**エラーレスポンス**:
- `404 Not Found`: テナントまたはユーザーが存在しない
- `409 Conflict`: ユーザーは既にテナントに所属
- `400 Bad Request`: 最大ユーザー数を超過
- `403 Forbidden`: 権限不足

**パフォーマンス要件**: < 500ms (P95)（認証認可サービスへの問い合わせを含む）

#### 3.4.2 GET /api/v1/tenants/{tenant_id}/users - テナント所属ユーザー一覧

**認可**: tenant-management: 閲覧者以上

**リクエスト**:
```http
GET /api/v1/tenants/tenant_acme/users?skip=0&limit=20&include_total=true
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**クエリパラメータ**:
- `skip` (optional, default=0): スキップ件数
- `limit` (optional, default=20, max=100): 取得件数
- `include_total` (optional, default=false): totalカウントを含めるか
  - `true`: 別クエリでCOUNT(*)を実行してtotalを返却（RU消費増）
  - `false`: totalフィールドを省略（パフォーマンス優先）

**レスポンス** (200 OK):
```json
{
  "data": [
    {
      "id": "tenant_user_tenant_acme_user_550e8400",
      "user_id": "user_550e8400-e29b-41d4-a716-446655440000",
      "user_details": {
        "username": "user@example.com",
        "display_name": "山田太郎",
        "email": "user@example.com",
        "is_active": true
      },
      "assigned_at": "2026-01-15T10:00:00Z",
      "assigned_by": "user_admin_001"
    }
  ],
  "pagination": {
    "skip": 0,
    "limit": 20,
    "total": 5
  }
}
```

**レスポンス（include_total=falseの場合）**:
```json
{
  "data": [...],
  "pagination": {
    "skip": 0,
    "limit": 20
  }
}
```

**totalカウント取得の実装**:
```python
async def list_tenant_users(
    tenant_id: str,
    skip: int = 0,
    limit: int = 20,
    include_total: bool = False
) -> dict:
    """
    テナント所属ユーザー一覧取得
    
    Args:
        tenant_id: テナントID
        skip: スキップ件数
        limit: 取得件数
        include_total: totalカウントを含めるか
    
    Performance:
        - include_total=false: 1クエリ（高速）
        - include_total=true: 2クエリ（データクエリ + COUNT(*））
    """
    # 1. ページネーションクエリ
    query = """
    SELECT * FROM c 
    WHERE c.tenant_id = @tenant_id 
      AND c.type = 'tenant_user'
    ORDER BY c.assigned_at DESC
    OFFSET @skip LIMIT @limit
    """
    parameters = [
        {"name": "@tenant_id", "value": tenant_id},
        {"name": "@skip", "value": skip},
        {"name": "@limit", "value": limit}
    ]
    
    tenant_users = await tenant_user_repository.query(
        query, parameters, partition_key=tenant_id
    )
    
    # 2. totalカウント取得（オプション）
    total = None
    if include_total:
        count_query = """
        SELECT VALUE COUNT(1) FROM c 
        WHERE c.tenant_id = @tenant_id 
          AND c.type = 'tenant_user'
        """
        count_params = [{"name": "@tenant_id", "value": tenant_id}]
        
        count_result = await tenant_user_repository.query_raw(
            count_query, count_params, partition_key=tenant_id
        )
        total = count_result[0] if count_result else 0
    
    # 3. ユーザー詳細を並列取得
    users_with_details = await get_tenant_users_with_details(
        tenant_users, service_token
    )
    
    # 4. レスポンス構築
    response = {
        "data": users_with_details,
        "pagination": {
            "skip": skip,
            "limit": limit
        }
    }
    
    if total is not None:
        response["pagination"]["total"] = total
    
    return response
```

**パフォーマンス要件**: 
- `include_total=false`: < 300ms (P95)
- `include_total=true`: < 400ms (P95)（COUNT(*)クエリ追加のため）

#### 3.4.3 DELETE /api/v1/tenants/{tenant_id}/users/{user_id} - ユーザー削除

**認可**: tenant-management: 管理者

**リクエスト**:
```http
DELETE /api/v1/tenants/tenant_acme/users/user_550e8400-e29b-41d4-a716-446655440000
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**レスポンス** (204 No Content):
（レスポンスボディなし）

**エラーレスポンス**:
- `404 Not Found`: TenantUserが存在しない
- `403 Forbidden`: 権限不足

**パフォーマンス要件**: < 200ms (P95)

#### 3.4.4 POST /api/v1/tenants/{tenant_id}/domains - ドメイン追加

**認可**: tenant-management: 管理者

**リクエスト**:
```http
POST /api/v1/tenants/tenant_acme/domains
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json

{
  "domain": "example.com"
}
```

**レスポンス** (201 Created):
```json
{
  "id": "domain_tenant_acme_example_com",
  "tenant_id": "tenant_acme",
  "domain": "example.com",
  "verified": false,
  "verification_token": "txt-verification-a1b2c3d4e5f6...",
  "verification_instructions": {
    "step1": "DNSプロバイダーにログイン",
    "step2": "以下のTXTレコードを追加:",
    "record_name": "_tenant_verification.example.com",
    "record_type": "TXT",
    "record_value": "txt-verification-a1b2c3d4e5f6..."
  },
  "created_at": "2026-02-01T11:00:00Z",
  "created_by": "user_admin_001"
}
```

**エラーレスポンス**:
- `404 Not Found`: テナントが存在しない
- `422 Unprocessable Entity`: ドメイン形式不正
- `403 Forbidden`: 権限不足

**パフォーマンス要件**: < 200ms (P95)

#### 3.4.5 POST /api/v1/tenants/{tenant_id}/domains/{domain_id}/verify - ドメイン検証

**認可**: tenant-management: 管理者

**リクエスト**:
```http
POST /api/v1/tenants/tenant_acme/domains/domain_tenant_acme_example_com/verify
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**レスポンス** (200 OK):
```json
{
  "id": "domain_tenant_acme_example_com",
  "domain": "example.com",
  "verified": true,
  "verified_at": "2026-02-01T11:30:00Z",
  "verified_by": "user_admin_001"
}
```

**エラーレスポンス**:
- `404 Not Found`: Domainが存在しない
- `422 Unprocessable Entity`: 検証失敗（TXTレコード不一致）
- `403 Forbidden`: 権限不足

**パフォーマンス要件**: < 1000ms (P95)（DNS問い合わせを含む）

#### 3.4.6 GET /api/v1/tenants/{tenant_id}/domains - ドメイン一覧

**認可**: tenant-management: 閲覧者以上

**リクエスト**:
```http
GET /api/v1/tenants/tenant_acme/domains?verified=true
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**クエリパラメータ**:
- `verified` (optional): 検証済みフィルタ（true/false）

**レスポンス** (200 OK):
```json
{
  "data": [
    {
      "id": "domain_tenant_acme_example_com",
      "domain": "example.com",
      "verified": true,
      "verified_at": "2026-01-02T12:00:00Z",
      "created_at": "2026-01-01T10:00:00Z"
    }
  ]
}
```

**パフォーマンス要件**: < 100ms (P95)

#### 3.4.7 DELETE /api/v1/tenants/{tenant_id}/domains/{domain_id} - ドメイン削除

**認可**: tenant-management: 管理者

**リクエスト**:
```http
DELETE /api/v1/tenants/tenant_acme/domains/domain_tenant_acme_example_com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**レスポンス** (204 No Content):
（レスポンスボディなし）

**エラーレスポンス**:
- `404 Not Found`: Domainが存在しない
- `403 Forbidden`: 権限不足

**パフォーマンス要件**: < 200ms (P95)

---

## 4. 非機能要件

### 4.1 パフォーマンス要件

| 項目 | 目標値 | 測定方法 | 測定条件 |
|------|--------|---------|---------|
| ユーザー招待 | < 500ms (P95) | Application Insights | 認証認可サービス問い合わせ含む |
| テナント所属ユーザー一覧取得 | < 300ms (P95) | Application Insights | 30日間のデータ |
| ユーザー削除 | < 200ms (P95) | Application Insights | 30日間のデータ |
| ドメイン追加 | < 200ms (P95) | Application Insights | 30日間のデータ |
| ドメイン検証 | < 1000ms (P95) | Application Insights | DNS問い合わせ含む |
| ドメイン一覧取得 | < 100ms (P95) | Application Insights | 30日間のデータ |
| ドメイン削除 | < 200ms (P95) | Application Insights | 30日間のデータ |

### 4.2 セキュリティ要件

| 要件ID | 要件名 | 実装方法 | 優先度 |
|-------|--------|---------|--------|
| SEC-TENANT-USER-001 | 認証必須 | 全APIエンドポイントでJWT認証を必須化 | 高 |
| SEC-TENANT-USER-002 | ロールベース認可 | 共通ライブラリ`require_role`デコレータ使用 | 高 |
| SEC-TENANT-USER-003 | テナント分離 | BaseRepositoryの3層チェック + アプリケーション層チェック | 高 |
| SEC-TENANT-USER-004 | ユーザー存在検証 | 認証認可サービスでのユーザー存在確認 | 高 |
| SEC-TENANT-DOMAIN-001 | ドメイン所有権検証 | DNS TXTレコードによる検証 | 高 |
| SEC-TENANT-DOMAIN-002 | 検証トークンのランダム性 | secrets.token_hex(16)使用 | 高 |
| SEC-AUDIT-001 | 監査ログ | 全操作（招待・削除）を記録 | 高 |

### 4.3 可用性要件

| 項目 | 目標値 | 測定方法 |
|------|--------|---------|
| 稼働率 (SLA) | 99.9% | Azure Monitor |
| 年間ダウンタイム | < 8.76時間 | Azure Monitor |
| 目標復旧時間 (RTO) | < 1時間 | インシデント記録 |
| 目標復旧時点 (RPO) | < 5分 | バックアップログ |

### 4.4 スケーラビリティ要件

| 項目 | Phase 1目標値 |
|------|------------|
| テナントあたり最大ユーザー数 | 500ユーザー |
| テナントあたり最大ドメイン数 | 10ドメイン |
| ユーザー招待の同時実行数 | 10リクエスト/秒 |

### 4.5 保守性要件

| 項目 | 要件 |
|------|------|
| コードカバレッジ | 75%以上（行カバレッジ） |
| ドキュメント | README.md、OpenAPI仕様書（/docs） |
| ロギング | 構造化ログ（JSON形式）、Application Insights統合 |
| エラーハンドリング | 共通ライブラリの標準エラーレスポンス使用 |

### 4.6 Cosmos DB非機能設定

#### 4.6.1 一貫性レベル

**Phase 1設定**: Session（セッション）一貫性

| 設定項目 | 値 | 理由 |
|---------|---|------|
| **一貫性レベル** | Session | パフォーマンスとコストのバランス、同一セッション内で整合性保証 |
| **自動フェイルオーバー** | 有効 | 可用性向上（Phase 2） |
| **リージョン** | 単一リージョン（Phase 1） | コスト最適化 |
| **プロビジョニング** | 手動スループット（Phase 1） | コスト予測可能性 |
| **RU設定** | 400 RU/s（開発）、4000 RU/s（本番Phase 1） | 負荷テスト結果に基づき調整 |

**設定例（Bicep）**:
```bicep
resource cosmosDbAccount 'Microsoft.DocumentDB/databaseAccounts@2023-04-15' = {
  name: cosmosAccountName
  location: location
  properties: {
    consistencyPolicy: {
      defaultConsistencyLevel: 'Session'
    }
    databaseAccountOfferType: 'Standard'
    locations: [
      {
        locationName: location
        failoverPriority: 0
        isZoneRedundant: false
      }
    ]
  }
}
```

#### 4.6.2 リトライポリシー

**Phase 1実装**: 共通ライブラリでの一元管理

| エラーコード | リトライ | 最大回数 | 間隔 | 理由 |
|------------|---------|---------|------|------|
| **429 (RU不足)** | ○ | 3回 | 指数バックオフ（1s, 2s, 4s） | 一時的なRU不足、待機で解決 |
| **503 (Service Unavailable)** | ○ | 3回 | 指数バックオフ | Azure側の一時的障害 |
| **408 (Timeout)** | ○ | 2回 | 固定1秒 | ネットワーク遅延 |
| **412 (Precondition Failed)** | ○ | 3回 | 固定100ms | 楽観的ロック競合 |
| **404, 400, 401** | × | - | - | クライアントエラー、リトライ不要 |

**実装例**:
```python
# common/database/cosmos.py
from azure.cosmos.aio import CosmosClient
from azure.cosmos import exceptions
from tenacity import retry, stop_after_attempt, wait_exponential

class CosmosDBClient:
    def __init__(self, connection_string: str):
        self.client = CosmosClient.from_connection_string(connection_string)
        self._configure_retry_policy()
    
    def _configure_retry_policy(self):
        """
        Cosmos DB SDKの組み込みリトライポリシー設定
        
        Note: Azure Cosmos DB Python SDKはデフォルトで一部のリトライを実施
        追加で明示的なリトライポリシーを実装
        """
        pass  # SDKデフォルトのリトライを使用
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        retry=retry_if_exception_type(
            (exceptions.CosmosHttpResponseError,)
        ),
        reraise=True
    )
    async def execute_with_retry(self, operation, *args, **kwargs):
        """
        カスタムリトライロジック付きCosmos DB操作
        
        Usage:
            result = await cosmos_client.execute_with_retry(
                container.create_item,
                body=item_data
            )
        """
        try:
            return await operation(*args, **kwargs)
        except exceptions.CosmosHttpResponseError as e:
            # 429, 503, 408はリトライ対象
            if e.status_code in (429, 503, 408):
                logger.warning(f"Cosmos DB error {e.status_code}, retrying...")
                raise  # リトライ実行
            else:
                # その他のエラーは即座に伝播
                raise
```

#### 4.6.3 インデックスポリシー

**最適化方針**: クエリパフォーマンスとRU消費のバランス

```json
{
  "indexingMode": "consistent",
  "automatic": true,
  "includedPaths": [
    {
      "path": "/tenantId/?",
      "indexes": [
        {
          "kind": "Hash",
          "dataType": "String",
          "precision": -1
        }
      ]
    },
    {
      "path": "/userId/?",
      "indexes": [
        {
          "kind": "Hash",
          "dataType": "String",
          "precision": -1
        }
      ]
    },
    {
      "path": "/assignedAt/?",
      "indexes": [
        {
          "kind": "Range",
          "dataType": "String",
          "precision": -1
        }
      ]
    },
    {
      "path": "/type/?"
    }
  ],
  "excludedPaths": [
    {
      "path": "/passwordHash/*"
    },
    {
      "path": "/verificationToken/*"
    }
  ]
}
```

**最適化の理由**:
- `tenantId`, `userId`: Hash index（等価検索が高速）
- `assignedAt`: Range index（範囲検索、ORDER BYが高速）
- `passwordHash`, `verificationToken`: インデックス除外（検索しない、RU節約）

---

## 5. データモデル

### 5.1 TenantUser エンティティ

#### 5.1.1 スキーマ

```python
class TenantUser(BaseModel):
    id: str                          # tenant_user_{tenant_id}_{user_id}
    tenant_id: str                   # パーティションキー
    type: str = "tenant_user"        # Cosmos DB識別子
    user_id: str                     # ユーザーID
    assigned_at: datetime            # 招待日時
    assigned_by: str                 # 招待者ユーザーID
```

#### 5.1.2 Cosmos DB格納例

```json
{
  "id": "tenant_user_tenant_acme_user_550e8400",
  "tenantId": "tenant_acme",
  "type": "tenant_user",
  "userId": "user_550e8400-e29b-41d4-a716-446655440000",
  "assignedAt": "2026-02-01T10:00:00Z",
  "assignedBy": "user_admin_001",
  "_ts": 1738408800
}
```

#### 5.1.3 インデックス設計

```json
{
  "indexingPolicy": {
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
      {"path": "/userId/?"},
      {"path": "/assignedAt/?"}
    ]
  }
}
```

### 5.2 Domain エンティティ

#### 5.2.1 スキーマ

```python
class Domain(BaseModel):
    id: str                          # domain_{tenant_id}_{slug化したdomain}
    tenant_id: str                   # パーティションキー
    type: str = "domain"             # Cosmos DB識別子
    domain: str                      # ドメイン名（例: example.com）
    verified: bool = False           # 検証済みフラグ
    verification_token: str          # 検証トークン
    verified_at: Optional[datetime]  # 検証完了日時
    verified_by: Optional[str]       # 検証者ユーザーID
    created_at: datetime             # 作成日時
    created_by: str                  # 作成者ユーザーID
```

#### 5.2.2 Cosmos DB格納例

```json
{
  "id": "domain_tenant_acme_example_com",
  "tenantId": "tenant_acme",
  "type": "domain",
  "domain": "example.com",
  "verified": true,
  "verificationToken": "txt-verification-a1b2c3d4e5f6...",
  "verifiedAt": "2026-02-01T11:30:00Z",
  "verifiedBy": "user_admin_001",
  "createdAt": "2026-02-01T11:00:00Z",
  "createdBy": "user_admin_001",
  "_ts": 1738410600
}
```

#### 5.2.3 インデックス設計

```json
{
  "indexingPolicy": {
    "indexingMode": "consistent",
    "automatic": true,
    "includedPaths": [
      {"path": "/domain/?"},
      {"path": "/verified/?"},
      {"path": "/createdAt/?"}
    ]
  }
}
```

### 5.3 データ整合性

#### 5.3.1 TenantUserの重複チェック

```python
async def create_tenant_user(
    self, 
    tenant_id: str, 
    user_id: str, 
    assigned_by: str
) -> TenantUser:
    """ユーザー招待（重複チェック + 最大ユーザー数チェック）"""
    # 1. 重複チェック
    existing = await self.tenant_user_repository.find_by_user(tenant_id, user_id)
    if existing:
        raise HTTPException(
            status_code=409,
            detail="User is already a member of this tenant"
        )
    
    # 2. テナント取得
    tenant = await self.tenant_repository.get(tenant_id, tenant_id)
    
    # 3. 最大ユーザー数チェック
    if tenant.user_count >= tenant.max_users:
        raise HTTPException(
            status_code=400,
            detail=f"Tenant has reached maximum user limit ({tenant.max_users})"
        )
    
    # 4. ユーザー存在確認（認証認可サービスに問い合わせ）
    user_exists = await self.auth_service_client.user_exists(user_id)
    if not user_exists:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    
    # 5. TenantUser作成
    tenant_user_id = f"tenant_user_{tenant_id}_{user_id}"
    tenant_user = TenantUser(
        id=tenant_user_id,
        tenant_id=tenant_id,
        user_id=user_id,
        assigned_at=datetime.utcnow(),
        assigned_by=assigned_by
    )
    
    await self.tenant_user_repository.create(tenant_user)
    
    # 6. user_countをインクリメント
    await self.tenant_service.increment_user_count(tenant_id)
    
    return tenant_user
```

#### 5.3.2 user_countの自動更新

```python
# app/services/tenant_service.py
from azure.cosmos.exceptions import CosmosHttpResponseError

async def increment_user_count(self, tenant_id: str) -> None:
    """
    テナントのユーザー数をインクリメント（楽観的ロック使用）
    
    Concurrency Control:
        - ETag（Entity Tag）を使用した楽観的ロック
        - 競合発生時は最大3回リトライ
        - リトライ間隔: 100ms固定
    
    Error Handling:
        - 412 Precondition Failed: 競合発生 → リトライ
        - 404 Not Found: テナント存在しない → 例外伝播
    """
    max_retries = 3
    retry_delay = 0.1  # 100ms
    
    for attempt in range(max_retries):
        try:
            # 1. 最新データを取得（ETag含む）
            tenant = await self.tenant_repository.get(tenant_id, tenant_id)
            
            if not tenant:
                raise HTTPException(
                    status_code=404,
                    detail="Tenant not found"
                )
            
            # 2. user_countをインクリメント
            tenant.user_count += 1
            tenant.updated_at = datetime.utcnow()
            
            # 3. ETagを使用してアトミックに更新（楽観的ロック）
            await self.tenant_repository.update_with_etag(
                tenant_id, 
                tenant_id, 
                tenant.model_dump(),
                etag=tenant._etag  # Cosmos DBから取得したETag
            )
            
            logger.info(f"Successfully incremented user_count for tenant {tenant_id}")
            return
            
        except CosmosHttpResponseError as e:
            if e.status_code == 412:  # Precondition Failed（競合）
                if attempt < max_retries - 1:
                    logger.warning(
                        f"Conflict updating user_count for {tenant_id}, "
                        f"retry {attempt + 1}/{max_retries}"
                    )
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    # 最大リトライ回数超過
                    logger.error(f"Failed to increment user_count after {max_retries} retries")
                    raise HTTPException(
                        status_code=409,
                        detail="Failed to update user count due to conflicts"
                    )
            else:
                # その他のエラーは即座に伝播
                raise

async def decrement_user_count(self, tenant_id: str) -> None:
    """
    テナントのユーザー数をデクリメント（楽観的ロック使用）
    
    同様の楽観的ロックを使用
    """
    max_retries = 3
    retry_delay = 0.1
    
    for attempt in range(max_retries):
        try:
            tenant = await self.tenant_repository.get(tenant_id, tenant_id)
            
            if not tenant:
                raise HTTPException(status_code=404, detail="Tenant not found")
            
            # 0以下にならないように
            tenant.user_count = max(0, tenant.user_count - 1)
            tenant.updated_at = datetime.utcnow()
            
            await self.tenant_repository.update_with_etag(
                tenant_id, 
                tenant_id, 
                tenant.model_dump(),
                etag=tenant._etag
            )
            
            logger.info(f"Successfully decremented user_count for tenant {tenant_id}")
            return
            
        except CosmosHttpResponseError as e:
            if e.status_code == 412:
                if attempt < max_retries - 1:
                    logger.warning(
                        f"Conflict updating user_count for {tenant_id}, "
                        f"retry {attempt + 1}/{max_retries}"
                    )
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    raise HTTPException(
                        status_code=409,
                        detail="Failed to update user count due to conflicts"
                    )
            else:
                raise

async def repair_user_count(self, tenant_id: str) -> int:
    """
    user_countの不整合を修復
    
    Usage:
        - 定期的なバッチジョブ（例: 毎日深夜）
        - 管理画面からの手動実行
        - データ移行後の整合性チェック
    
    Process:
        1. TenantUserの実際の件数をCosmos DBでカウント
        2. Tenantの user_count と比較
        3. 不一致の場合は実際の件数で上書き
    
    Returns:
        int: 修復後の正しいuser_count
    """
    # 1. TenantUserの実際の件数を取得
    query = """
    SELECT VALUE COUNT(1) 
    FROM c 
    WHERE c.tenant_id = @tenant_id 
      AND c.type = 'tenant_user'
    """
    parameters = [{"name": "@tenant_id", "value": tenant_id}]
    
    actual_count_result = await self.tenant_repository.query_raw(
        query, 
        parameters, 
        partition_key=tenant_id
    )
    actual_count = actual_count_result[0] if actual_count_result else 0
    
    # 2. Tenantを取得
    tenant = await self.tenant_repository.get(tenant_id, tenant_id)
    
    # 3. 不一致の場合は修復
    if tenant.user_count != actual_count:
        logger.warning(
            f"user_count mismatch for {tenant_id}: "
            f"stored={tenant.user_count}, actual={actual_count}"
        )
        
        tenant.user_count = actual_count
        tenant.updated_at = datetime.utcnow()
        
        await self.tenant_repository.update(
            tenant_id, 
            tenant_id, 
            tenant.model_dump()
        )
        
        logger.info(f"Repaired user_count for {tenant_id}: {actual_count}")
    
    return actual_count
```

**BaseRepository.update_with_etagの実装**:
```python
# common/database/repository.py
async def update_with_etag(
    self, 
    id: str, 
    partition_key: str, 
    data: dict,
    etag: str
) -> T:
    """
    ETagを使用した楽観的ロックによる更新
    
    Args:
        id: アイテムID
        partition_key: パーティションキー
        data: 更新データ
        etag: 楽観的ロック用のETag
    
    Raises:
        CosmosHttpResponseError(412): 競合発生（他のプロセスが先に更新）
    """
    # ETagをif_matchに設定して更新
    updated = await self.container.upsert_item(
        body=data,
        if_match=etag  # この条件が満たされない場合は412エラー
    )
    return self.model_class(**updated)
```

---

## 6. エラーコード一覧

### 6.1 TenantUser関連エラー

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|-----------|--------|
| TENANT_USER_001_NOT_FOUND | 404 | TenantUser not found | TenantUserが存在しない |
| TENANT_USER_002_DUPLICATE | 409 | User is already a member of this tenant | ユーザーは既にテナントに所属 |
| TENANT_USER_003_USER_NOT_FOUND | 404 | User not found | 招待するユーザーが存在しない |
| TENANT_USER_004_MAX_USERS | 400 | Tenant has reached maximum user limit | 最大ユーザー数を超過 |

### 6.2 Domain関連エラー

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|-----------|--------|
| DOMAIN_001_NOT_FOUND | 404 | Domain not found | Domainが存在しない |
| DOMAIN_002_INVALID_FORMAT | 422 | Invalid domain format | ドメイン形式不正 |
| DOMAIN_003_VERIFICATION_FAILED | 422 | Domain verification failed: TXT record not found or mismatch | 検証失敗 |
| DOMAIN_004_ALREADY_VERIFIED | 400 | Domain is already verified | 既に検証済み |

### 6.3 認可エラー

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|-----------|--------|
| AUTHZ_001_INSUFFICIENT_ROLE | 403 | Role required: tenant-management:管理者 | ロール不足 |
| AUTHZ_002_TENANT_ISOLATION_VIOLATION | 403 | Cannot access tenant data in different tenant | テナント分離違反 |

---

## 7. テスト要件

### 7.1 単体テスト

#### 7.1.1 Repository テスト
- **TenantUserRepository**
  - `test_create_tenant_user`: TenantUser作成
  - `test_find_by_user`: ユーザーIDでTenantUser検索
  - `test_list_tenant_users`: TenantUser一覧取得
  - `test_delete_tenant_user`: TenantUser削除
- **DomainRepository**
  - `test_create_domain`: Domain作成
  - `test_update_domain_verification`: ドメイン検証更新
  - `test_list_domains`: Domain一覧取得
  - `test_delete_domain`: Domain削除

#### 7.1.2 Service テスト
- **TenantUserService**
  - `test_invite_user_success`: ユーザー招待成功
  - `test_invite_user_duplicate`: 重複招待エラー
  - `test_invite_user_max_users_exceeded`: 最大ユーザー数超過エラー
  - `test_invite_user_not_found`: ユーザー存在しないエラー
  - `test_remove_user_success`: ユーザー削除成功
  - `test_user_count_increment`: user_count自動インクリメント
  - `test_user_count_decrement`: user_count自動デクリメント
- **DomainService**
  - `test_add_domain_success`: ドメイン追加成功
  - `test_verify_domain_success`: ドメイン検証成功
  - `test_verify_domain_failed`: ドメイン検証失敗
  - `test_generate_verification_token`: 検証トークン生成
  - `test_dns_verification`: DNS TXTレコード検証

#### 7.1.3 API テスト
- **TenantUser管理API**
  - `test_invite_user_success`: ユーザー招待成功
  - `test_invite_user_unauthorized`: 権限なし（403）
  - `test_list_tenant_users_success`: ユーザー一覧取得成功
  - `test_remove_user_success`: ユーザー削除成功
- **Domain管理API**
  - `test_add_domain_success`: ドメイン追加成功
  - `test_verify_domain_success`: ドメイン検証成功
  - `test_list_domains_success`: ドメイン一覧取得成功
  - `test_delete_domain_success`: ドメイン削除成功

### 7.2 統合テスト

#### 7.2.1 統合テストシナリオ

**シナリオ1: ユーザー招待フロー（正常系）**
```python
async def test_user_invitation_flow():
    """
    ユーザー招待の統合テスト
    
    テスト環境:
        - 認証認可サービスモック
        - Cosmos DBエミュレーター
        - DNS検証はスキップ（モックで代替）
    """
    # 1. テナント作成
    tenant = await create_tenant("test-tenant")
    
    # 2. 認証認可サービスモックの設定
    # ユーザー存在を返却するモック
    mock_auth_service.register_user("user_123", {
        "id": "user_123",
        "username": "john.doe",
        "email": "john@example.com"
    })
    
    # 3. ユーザー招待
    response = await client.post(
        f"/api/v1/tenants/{tenant.id}/users",
        json={"user_id": "user_123"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )
    
    # 4. 検証
    assert response.status_code == 201
    assert response.json()["user_id"] == "user_123"
    
    # 5. Cosmos DBでTenantUserが作成されているか確認
    tenant_user = await tenant_user_repository.get(
        f"tenant_user_{tenant.id}_user_123",
        tenant.id
    )
    assert tenant_user is not None
    
    # 6. user_countが更新されているか確認
    updated_tenant = await tenant_repository.get(tenant.id, tenant.id)
    assert updated_tenant.user_count == 1

async def test_user_invitation_auth_service_failure():
    """
    認証認可サービスダウン時の統合テスト
    
    期待動作:
        - 503エラーを返却
        - TenantUserは作成されない
        - user_countは変更されない
    """
    tenant = await create_tenant("test-tenant")
    
    # 認証認可サービスモックを503エラーに設定
    mock_auth_service.set_error(503, "Service Unavailable")
    
    # ユーザー招待を試行
    response = await client.post(
        f"/api/v1/tenants/{tenant.id}/users",
        json={"user_id": "user_123"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )
    
    # 検証
    assert response.status_code == 503
    assert "unavailable" in response.json()["error"]["message"].lower()
    
    # TenantUserが作成されていないことを確認
    tenant_user = await tenant_user_repository.get(
        f"tenant_user_{tenant.id}_user_123",
        tenant.id
    )
    assert tenant_user is None
    
    # user_countが変更されていないことを確認
    tenant = await tenant_repository.get(tenant.id, tenant.id)
    assert tenant.user_count == 0
```

**シナリオ2: ドメイン検証フロー（正常系）**
```python
async def test_domain_verification_flow():
    """
    ドメイン検証の統合テスト
    
    DNSモック:
        - dnspythonのResolverをモック化
        - 指定したTXTレコードを返却
    """
    tenant = await create_tenant("test-tenant")
    
    # 1. ドメイン追加
    response = await client.post(
        f"/api/v1/tenants/{tenant.id}/domains",
        json={"domain": "example.com"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )
    
    assert response.status_code == 201
    domain_id = response.json()["id"]
    verification_token = response.json()["verification_token"]
    
    # 2. DNSモックの設定
    # _tenant_verification.example.com のTXTレコードを返却
    mock_dns_resolver.add_txt_record(
        "_tenant_verification.example.com",
        verification_token
    )
    
    # 3. ドメイン検証
    response = await client.post(
        f"/api/v1/tenants/{tenant.id}/domains/{domain_id}/verify",
        headers={"Authorization": f"Bearer {jwt_token}"}
    )
    
    # 4. 検証
    assert response.status_code == 200
    assert response.json()["verified"] is True
    assert response.json()["verified_at"] is not None
    
    # 5. Cosmos DBで検証済みフラグが立っているか確認
    domain = await domain_repository.get(domain_id, tenant.id)
    assert domain.verified is True

async def test_domain_verification_dns_timeout():
    """
    DNS検証タイムアウト時の統合テスト
    
    期待動作:
        - 最大3回リトライ
        - 503エラーを返却
        - ドメインの検証済みフラグは変更されない
    """
    tenant = await create_tenant("test-tenant")
    domain = await create_domain(tenant.id, "example.com")
    
    # DNSモックをタイムアウトに設定
    mock_dns_resolver.set_timeout(domain.domain)
    
    # ドメイン検証を試行
    response = await client.post(
        f"/api/v1/tenants/{tenant.id}/domains/{domain.id}/verify",
        headers={"Authorization": f"Bearer {jwt_token}"}
    )
    
    # 検証
    assert response.status_code == 503
    assert "timeout" in response.json()["error"]["message"].lower()
    
    # 検証済みフラグが変更されていないことを確認
    domain = await domain_repository.get(domain.id, tenant.id)
    assert domain.verified is False
```

**シナリオ3: user_count競合制御テスト**
```python
async def test_concurrent_user_invitation():
    """
    複数ユーザー同時招待時の競合制御テスト
    
    テスト内容:
        - 10ユーザーを並列で招待
        - user_countが正確に10になることを確認
        - 楽観的ロックとリトライが正しく動作することを確認
    """
    tenant = await create_tenant("test-tenant")
    
    # 10ユーザーを認証認可サービスモックに登録
    user_ids = [f"user_{i}" for i in range(10)]
    for user_id in user_ids:
        mock_auth_service.register_user(user_id, {
            "id": user_id,
            "username": f"user{user_id}",
            "email": f"user{user_id}@example.com"
        })
    
    # 並列で招待
    tasks = [
        client.post(
            f"/api/v1/tenants/{tenant.id}/users",
            json={"user_id": user_id},
            headers={"Authorization": f"Bearer {jwt_token}"}
        )
        for user_id in user_ids
    ]
    
    responses = await asyncio.gather(*tasks)
    
    # 全て成功していることを確認
    for response in responses:
        assert response.status_code == 201
    
    # user_countが正確に10であることを確認
    tenant = await tenant_repository.get(tenant.id, tenant.id)
    assert tenant.user_count == 10
    
    # TenantUserが10件作成されていることを確認
    tenant_users = await tenant_user_repository.list_by_tenant(tenant.id)
    assert len(tenant_users) == 10

async def test_user_count_repair():
    """
    user_count修復機能のテスト
    
    シナリオ:
        - 意図的にuser_countを不正な値に設定
        - repair_user_count()を実行
        - 正しい値に修復されることを確認
    """
    tenant = await create_tenant("test-tenant")
    
    # 3ユーザー招待
    for i in range(3):
        await invite_user(tenant.id, f"user_{i}")
    
    # 意図的にuser_countを不正な値に設定
    tenant = await tenant_repository.get(tenant.id, tenant.id)
    tenant.user_count = 100  # 不正な値
    await tenant_repository.update(tenant.id, tenant.id, tenant.model_dump())
    
    # 修復実行
    repaired_count = await tenant_service.repair_user_count(tenant.id)
    
    # 検証
    assert repaired_count == 3
    
    tenant = await tenant_repository.get(tenant.id, tenant.id)
    assert tenant.user_count == 3
```

#### 7.2.2 認証認可サービスモック仕様

```python
# tests/mocks/auth_service_mock.py
class AuthServiceMock:
    """
    認証認可サービスのモック実装
    
    機能:
        - ユーザー存在確認API（GET /api/v1/users/{user_id}）のモック
        - ユーザー詳細情報取得のモック
        - エラーシミュレーション（503, 404, タイムアウト）
    """
    
    def __init__(self):
        self.users: Dict[str, dict] = {}
        self.error_status: Optional[int] = None
        self.error_message: Optional[str] = None
        self.delay: float = 0.0  # レスポンス遅延（秒）
    
    def register_user(self, user_id: str, user_data: dict):
        """モックにユーザーを登録"""
        self.users[user_id] = user_data
    
    def set_error(self, status_code: int, message: str):
        """次のリクエストでエラーを返却"""
        self.error_status = status_code
        self.error_message = message
    
    def set_delay(self, seconds: float):
        """レスポンス遅延を設定（タイムアウトテスト用）"""
        self.delay = seconds
    
    async def get_user(self, user_id: str) -> Response:
        """GET /api/v1/users/{user_id} のモック"""
        # 遅延シミュレーション
        if self.delay > 0:
            await asyncio.sleep(self.delay)
        
        # エラーシミュレーション
        if self.error_status:
            return Response(
                status_code=self.error_status,
                content=json.dumps({"error": self.error_message})
            )
        
        # ユーザー存在確認
        if user_id in self.users:
            return Response(
                status_code=200,
                content=json.dumps(self.users[user_id])
            )
        else:
            return Response(
                status_code=404,
                content=json.dumps({"error": "User not found"})
            )
```

#### 7.2.3 DNSモック仕様

```python
# tests/mocks/dns_mock.py
class DNSResolverMock:
    """
    dnspythonのResolverモック
    
    機能:
        - TXTレコードの登録
        - DNS問い合わせのシミュレーション
        - タイムアウト、NXDOMAIN、NoAnswerのシミュレーション
    """
    
    def __init__(self):
        self.txt_records: Dict[str, List[str]] = {}
        self.timeout_domains: Set[str] = set()
        self.nxdomain_domains: Set[str] = set()
    
    def add_txt_record(self, record_name: str, value: str):
        """TXTレコードを登録"""
        if record_name not in self.txt_records:
            self.txt_records[record_name] = []
        self.txt_records[record_name].append(value)
    
    def set_timeout(self, domain: str):
        """指定ドメインをタイムアウトに設定"""
        self.timeout_domains.add(domain)
    
    def set_nxdomain(self, domain: str):
        """指定ドメインをNXDOMAINに設定"""
        self.nxdomain_domains.add(domain)
    
    async def resolve(self, record_name: str, record_type: str):
        """dns.resolver.Resolver.resolve()のモック"""
        domain = record_name.replace("_tenant_verification.", "")
        
        # タイムアウトシミュレーション
        if domain in self.timeout_domains:
            await asyncio.sleep(6)  # タイムアウト超過
            raise dns.exception.Timeout()
        
        # NXDOMAINシミュレーション
        if domain in self.nxdomain_domains:
            raise dns.resolver.NXDOMAIN()
        
        # TXTレコード返却
        if record_name in self.txt_records:
            # dnspython形式でデータを返却
            class MockRData:
                def __init__(self, strings):
                    self.strings = [s.encode('utf-8') for s in strings]
            
            return [MockRData(self.txt_records[record_name])]
        else:
            raise dns.resolver.NoAnswer()
```

### 7.3 セキュリティテスト

| テストケース | 期待結果 |
|------------|---------|
| 認証トークンなしでAPI呼び出し | 401エラー |
| 閲覧者ロールでユーザー招待 | 403エラー |
| 他テナントのユーザー招待試行 | 403エラー |
| 重複ユーザー招待 | 409エラー |
| 最大ユーザー数超過招待 | 400エラー |
| 不正なドメイン形式 | 422エラー |

### 7.4 パフォーマンステスト

#### 7.4.1 負荷条件と目標値

| テストケース | 同時ユーザー数 | リクエスト数 | 期間 | 目標レスポンスタイム (P95) | 目標スループット | 備考 |
|------------|--------------|-------------|------|------------------------|---------------|------|
| ユーザー招待 | 10 | 1000 | 5分 | < 500ms | 20 req/s | 認証認可サービス問い合わせ含む |
| ユーザー一覧取得 | 50 | 5000 | 5分 | < 300ms | 100 req/s | 20件/ページ |
| ドメイン検証 | 5 | 100 | 10分 | < 1000ms | 2 req/s | DNS問い合わせ含む |
| 並列ユーザー招待 | 10 | 100 | 2分 | < 1000ms | 10 req/s | 同一テナントに対する並列招待 |

#### 7.4.2 負荷テストシナリオ

**シナリオ1: ユーザー招待の負荷テスト**
```python
# locustfile.py
from locust import HttpUser, task, between

class TenantManagementUser(HttpUser):
    wait_time = between(1, 3)
    
    def on_start(self):
        """テスト開始時にログインしてJWTを取得"""
        response = self.client.post("/api/v1/auth/login", json={
            "username": "admin",
            "password": "password"
        })
        self.token = response.json()["access_token"]
    
    @task(5)  # 重み5（最も頻繁に実行）
    def invite_user(self):
        """ユーザー招待負荷テスト"""
        tenant_id = f"tenant_{random.randint(1, 10)}"
        user_id = f"user_{uuid.uuid4()}"
        
        with self.client.post(
            f"/api/v1/tenants/{tenant_id}/users",
            json={"user_id": user_id},
            headers={"Authorization": f"Bearer {self.token}"},
            catch_response=True
        ) as response:
            if response.status_code == 201:
                response.success()
            elif response.status_code == 409:
                # 重複は許容（再試行不要）
                response.success()
            else:
                response.failure(f"Unexpected status: {response.status_code}")
    
    @task(10)  # 重み10（頻繁に実行）
    def list_users(self):
        """ユーザー一覧取得負荷テスト"""
        tenant_id = f"tenant_{random.randint(1, 10)}"
        skip = random.randint(0, 5) * 20
        
        with self.client.get(
            f"/api/v1/tenants/{tenant_id}/users?skip={skip}&limit=20",
            headers={"Authorization": f"Bearer {self.token}"},
            catch_response=True
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"Unexpected status: {response.status_code}")
    
    @task(1)  # 重み1（低頻度）
    def verify_domain(self):
        """ドメイン検証負荷テスト"""
        tenant_id = f"tenant_{random.randint(1, 10)}"
        domain_id = f"domain_{tenant_id}_example_com"
        
        with self.client.post(
            f"/api/v1/tenants/{tenant_id}/domains/{domain_id}/verify",
            headers={"Authorization": f"Bearer {self.token}"},
            catch_response=True
        ) as response:
            if response.status_code in (200, 422):
                # 検証成功または失敗は両方許容
                response.success()
            else:
                response.failure(f"Unexpected status: {response.status_code}")
```

**実行コマンド**:
```bash
# ユーザー招待の負荷テスト（10同時ユーザー、5分間）
locust -f locustfile.py \
  --host http://localhost:8000 \
  --users 10 \
  --spawn-rate 2 \
  --run-time 5m \
  --html performance-report.html

# スループットテスト（100同時ユーザー、10分間）
locust -f locustfile.py \
  --host http://localhost:8000 \
  --users 100 \
  --spawn-rate 10 \
  --run-time 10m \
  --csv throughput-results
```

#### 7.4.3 負荷テスト成功基準

| 指標 | 目標値 | 測定方法 | 判定基準 |
|-----|--------|---------|---------|
| **レスポンスタイム (P95)** | 各API目標値以内 | Locustレポート | P95が目標値以下 |
| **エラー率** | < 1% | Locustレポート | 総リクエスト数の99%以上が成功 |
| **スループット** | 目標値以上 | Locustレポート | req/sが目標値以上 |
| **Cosmos DB RU消費** | < 10,000 RU/s | Azure Monitor | 平均RU消費が10,000未満 |
| **CPU使用率** | < 70% | Azure Monitor | App Service CPU平均使用率 |
| **メモリ使用率** | < 80% | Azure Monitor | App Serviceメモリ平均使用率 |

#### 7.4.4 ストレステスト（限界値の確認）

**目的**: システムの限界を確認し、ボトルネックを特定

**負荷条件**:
- 同時ユーザー数: 10 → 50 → 100 → 200（段階的に増加）
- 各段階: 5分間
- 期待動作: 200同時ユーザーでもエラー率 < 5%

**測定項目**:
- レスポンスタイムの推移
- エラー率の推移
- Cosmos DB RU消費の推移
- 認証認可サービスへのリクエストタイムアウト発生率

**ボトルネック特定**:
- Cosmos DB: RU不足（429エラー）の発生頻度
- 認証認可サービス: タイムアウト発生率
- アプリケーション: CPU/メモリ使用率

#### 7.4.5 耐久テスト（長時間運用の安定性）

**目的**: 長時間運用時のメモリリーク、コネクションリークの検出

**負荷条件**:
- 同時ユーザー数: 20
- 期間: 24時間
- リクエストパターン: ユーザー招待、一覧取得、削除を繰り返し

**測定項目**:
- メモリ使用量の推移（時系列）
- アクティブコネクション数の推移
- エラー発生パターン（時間帯別）

**成功基準**:
- メモリ使用量が一定範囲内（増加し続けない）
- エラー率が24時間を通じて < 1%
- レスポンスタイムが劣化しない

### 7.5 カバレッジ目標

- **行カバレッジ**: 75%以上
- **分岐カバレッジ**: 70%以上
- **関数カバレッジ**: 80%以上

---

## 8. 依存関係

### 8.1 共通ライブラリ依存

| モジュール | 使用関数/クラス | 用途 |
|----------|--------------|------|
| common.auth.dependencies | require_role | ロール認可 |
| common.database.repository | BaseRepository | CRUD操作基底クラス |
| common.logging | get_logger | 構造化ログ |
| common.models.base | BaseModel | モデル基底クラス |

### 8.2 外部サービス依存

| サービス | 用途 | 実装 |
|---------|------|------|
| Azure Cosmos DB | データ永続化 | ✅ |
| 認証認可サービス | ユーザー存在確認 | ✅ |
| DNS | ドメイン検証 | ✅（dnspythonライブラリ） |

### 8.3 データ依存

- **Tenantエンティティ**: タスク05で実装済み
- **Userエンティティ**: 認証認可サービス（タスク03）で実装済み

---

## 9. 制約事項

### 9.1 技術的制約

- Python 3.11+
- FastAPI 0.100+
- dnspython 2.4+（DNS検証用）
- httpx 0.24+（認証認可サービスへのHTTPリクエスト用）

### 9.2 実装上の制約

- Phase 1ではユーザー招待メール送信は未実装
- Phase 1ではドメインベースのメールアドレス制限は未実装
- Phase 1ではTenantUserへのロール割り当ては未実装（全体的なロール管理のみ）

### 9.3 運用上の制約

- DNS検証は管理者が手動でDNS設定を行う必要がある
- DNS伝播には最大48時間かかる場合がある

---

## 10. 受け入れ基準

### 10.1 機能的受け入れ基準

- [ ] 全APIエンドポイントが実装され、動作する
- [ ] POST /api/v1/tenants/{tenant_id}/users: ユーザー招待
- [ ] GET /api/v1/tenants/{tenant_id}/users: テナント所属ユーザー一覧
- [ ] DELETE /api/v1/tenants/{tenant_id}/users/{user_id}: ユーザー削除
- [ ] POST /api/v1/tenants/{tenant_id}/domains: ドメイン追加
- [ ] POST /api/v1/tenants/{tenant_id}/domains/{domain_id}/verify: ドメイン検証
- [ ] GET /api/v1/tenants/{tenant_id}/domains: ドメイン一覧
- [ ] DELETE /api/v1/tenants/{tenant_id}/domains/{domain_id}: ドメイン削除
- [ ] user_countが自動的に更新される
- [ ] ロールベース認可が動作（管理者）
- [ ] テナント分離が強制される

### 10.2 非機能的受け入れ基準

- [ ] パフォーマンス目標達成（各API応答時間）
- [ ] セキュリティ要件達成（ロール認可、テナント分離、ドメイン検証）
- [ ] テストカバレッジ 75%以上
- [ ] 全テストが合格
- [ ] OpenAPI仕様書が更新される (/docs)

### 10.3 運用的受け入れ基準

- [ ] ローカル環境で起動・動作確認
- [ ] README.mdが更新され、新機能の説明が記載
- [ ] 環境変数が.env.exampleに追加（認証認可サービスURL等）

---

## 11. リスク分析

| リスク | 影響度 | 発生確率 | 緩和策 | 検証方法 |
|-------|--------|---------|--------|---------|
| 認証認可サービスのダウンタイム | 高 | 低 | リトライ処理、タイムアウト設定、部分的失敗の許容 | 統合テストでサービスダウンをシミュレーション |
| DNS検証の遅延 | 中 | 中 | DNS伝播に時間がかかることをユーザーに周知、最大3回リトライ、5秒タイムアウト | DNSモックでタイムアウトシミュレーション |
| user_count不整合 | 中 | 低 | ETag楽観的ロック、リトライ処理、定期的な修復バッチジョブ | 並列招待テストで競合発生を確認 |
| 最大ユーザー数チェックの競合 | 低 | 中 | 楽観的ロック、最大3回再試行 | 並列招待テストで検証 |
| Cosmos DB RU不足 | 高 | 中 | パーティションキー設計の最適化、プロビジョニング済みスループット設定、自動スケール有効化 | 負荷テストでRU消費を監視 |
| 認証認可サービスのAPI変更 | 中 | 低 | バージョニング、統合テストでの継続的検証 | CI/CDパイプラインで統合テスト実行 |

---

## 12. 設計判断の根拠

### 12.1 user_count自動更新の選択理由

#### 背景
テナントの所属ユーザー数を管理する方法として、以下の選択肢があります：
1. **手動管理**: 管理者が手動でuser_countを更新
2. **都度カウント**: ユーザー一覧取得時に毎回Cosmos DBでCOUNT(*)を実行
3. **自動更新**: TenantUser作成・削除時に自動的にuser_countを更新（**採用**）

#### 選択理由

| 観点 | 手動管理 | 都度カウント | 自動更新（採用） |
|-----|---------|------------|--------------|
| **パフォーマンス** | ○（読み取りのみ） | △（毎回COUNT(*)が必要、RU消費大） | ○（事前に計算済み） |
| **正確性** | △（手動ミスのリスク） | ○（常に正確） | ○（競合制御で保証） |
| **開発工数** | △（UI実装必要） | ○（シンプル） | △（競合制御実装必要） |
| **運用負荷** | ×（管理者の負担） | ○（自動） | ○（自動） |
| **スケーラビリティ** | ○ | △（テナント規模に依存） | ○ |

**結論**: 自動更新を採用
- **理由1**: パフォーマンス優位性
  - テナント一覧取得時に毎回COUNT(*)を実行すると、RU消費が増加
  - user_countを事前計算することで、一覧取得のレスポンスタイムを50%削減
- **理由2**: ユーザー体験の向上
  - 管理画面でのテナント一覧表示が高速
  - 最大ユーザー数チェックが瞬時に実行可能
- **理由3**: スケーラビリティ
  - テナントのユーザー数が増加してもパフォーマンスが劣化しない
  - Cosmos DBのRU消費を抑制

**トレードオフ**: 
- 競合制御の実装が必要（ETag楽観的ロック）
- 不整合発生時の修復機能が必要（`repair_user_count()`）

### 12.2 DNS TXT検証方式の選択根拠

#### 背景
ドメイン所有権を検証する方法として、以下の選択肢があります：
1. **メール検証**: ドメインのadmin@, postmaster@にメール送信
2. **HTTPファイル検証**: ドメイン直下に検証ファイルを配置
3. **DNS TXT検証**: DNSにTXTレコードを追加（**採用**）
4. **DNS CNAME検証**: DNSにCNAMEレコードを追加

#### 選択理由

| 観点 | メール検証 | HTTPファイル検証 | DNS TXT検証（採用） | DNS CNAME検証 |
|-----|----------|----------------|-----------------|--------------|
| **実装容易性** | △（メール送信機能必要） | ○ | ○ | ○ |
| **ユーザー操作** | △（メール受信・クリック必要） | △（Webサーバー設定必要） | ○（DNS設定のみ） | ○（DNS設定のみ） |
| **検証速度** | △（メール遅延あり） | ○（即座） | ○（DNS伝播後即座） | ○（DNS伝播後即座） |
| **セキュリティ** | △（メールスプーフィングリスク） | ○ | ○ | ○ |
| **業界標準** | △ | ○（Let's Encrypt） | ○（Google/AWS/Cloudflare） | ○ |
| **Phase 2拡張性** | △ | △ | ○（他のDNS検証も追加可能） | ○ |

**結論**: DNS TXT検証を採用

**理由1**: 業界標準
- Google Workspace、AWS Certificate Manager、Cloudflareなどで広く採用
- ユーザーにとって馴染みのある検証方法

**理由2**: 実装のシンプルさ
- メール送信機能、Webサーバー設定が不要
- dnspythonライブラリで簡単に実装可能

**理由3**: セキュアな検証
- DNSは改ざんが困難（DNSSEC対応ドメインでは署名検証可能）
- 検証トークンのランダム性により推測不可能

**理由4**: 自動化しやすい
- APIから検証を即座に実行可能
- 人手を介さない自動検証が可能

**トレードオフ**:
- DNS伝播に時間がかかる（最大48時間、通常15分～1時間）
- ユーザーはDNS設定方法を理解している必要がある

### 12.3 Cosmos DBリトライポリシーと一貫性レベル

#### リトライポリシー

**採用方針**: 指数バックオフによる自動リトライ

| エラーコード | リトライ | 理由 | リトライ回数 | 間隔 |
|------------|---------|------|------------|------|
| **429 (RU不足)** | ○ | 一時的なRU不足、リトライで解決可能 | 最大3回 | 指数バックオフ（1s, 2s, 4s） |
| **503 (サービス一時停止)** | ○ | Azure側の一時的な障害 | 最大3回 | 指数バックオフ |
| **408 (タイムアウト)** | ○ | ネットワーク遅延 | 最大2回 | 1秒間隔 |
| **412 (Precondition Failed)** | ○ | 楽観的ロック競合 | 最大3回 | 100ms固定 |
| **404 (Not Found)** | × | データ不存在、リトライ不要 | - | - |
| **400 (Bad Request)** | × | クライアントエラー、リトライ不要 | - | - |

**実装**:
```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    retry=retry_if_exception_type(CosmosHttpResponseError),
    reraise=True
)
async def cosmos_operation_with_retry():
    """Cosmos DB操作（自動リトライ付き）"""
    pass
```

#### 一貫性レベル

**採用方針**: Session consistency（**デフォルト、Phase 1推奨**）

| 一貫性レベル | 読み取りレイテンシー | 書き込みレイテンシー | 整合性保証 | RUコスト | 採用判断 |
|------------|-----------------|-----------------|----------|---------|---------|
| **Strong** | 高い | 高い | 最強 | 2倍 | Phase 2（金融系） |
| **Bounded Staleness** | 中程度 | 中程度 | K個の更新またはT秒以内 | 2倍 | Phase 2（地理分散） |
| **Session（採用）** | 低い | 低い | 同一セッション内で整合 | 標準 | **Phase 1推奨** |
| **Consistent Prefix** | 低い | 低い | プレフィックス整合 | 標準 | 不採用 |
| **Eventual** | 最も低い | 最も低い | 最終的整合 | 0.5倍 | 不採用（不整合リスク） |

**選択理由**:
1. **パフォーマンスとコストのバランス**
   - Strongの半分のRUコスト
   - Eventualより高い整合性保証
2. **ユーザー体験**
   - ユーザー自身の操作結果は即座に反映（Session一貫性）
   - 例: ユーザー招待後、即座に一覧に表示される
3. **Phase 1の要件に十分**
   - 単一リージョンデプロイ
   - 高トランザクション性は不要

**Phase 2での見直し**:
- 金融関連機能: Strong一貫性に変更
- 地理分散デプロイ: Bounded Staleness に変更

### 12.4 認証認可サービスダウン時の詳細動作

#### 障害シナリオ

**シナリオ1: ユーザー招待時の認証認可サービスダウン**

| ステップ | 動作 | ユーザーへの影響 | 復旧方法 |
|---------|------|---------------|---------|
| 1. ユーザー存在確認失敗 | リトライ3回（指数バックオフ） | 一時的な遅延（最大7秒） | 自動リトライで復旧 |
| 2. リトライ後も失敗 | 503エラー返却 | エラーメッセージ表示「サービス一時利用不可」 | ユーザーが後で再試行 |
| 3. TenantUser未作成 | Rollback（何も保存されない） | データ不整合なし | サービス復旧後に再試行 |
| 4. user_count未更新 | 更新されない | 整合性維持 | - |

**実装**:
```python
async def invite_user(tenant_id: str, user_id: str, current_user: User):
    """
    ユーザー招待（認証認可サービスダウン時の動作）
    
    Failure Mode:
        - 認証認可サービスダウン → 503エラー、TenantUser未作成
        - 部分的失敗なし（原子性保証）
    """
    try:
        # 1. ユーザー存在確認（リトライ3回）
        user_exists = await verify_user_exists(user_id)
        
        if not user_exists:
            raise HTTPException(status_code=404, detail="User not found")
        
        # 2. TenantUser作成（ここまで到達しない場合は何も保存されない）
        tenant_user = await create_tenant_user(tenant_id, user_id, current_user.id)
        
        # 3. user_count更新
        await increment_user_count(tenant_id)
        
        return tenant_user
        
    except HTTPException as e:
        if e.status_code == 503:
            # 認証認可サービスダウン時のログ記録
            logger.error(
                "User invitation failed due to auth service unavailability",
                extra={
                    "tenant_id": tenant_id,
                    "user_id": user_id,
                    "performed_by": current_user.id
                }
            )
        raise
```

**シナリオ2: ユーザー一覧取得時の認証認可サービスダウン**

| ステップ | 動作 | ユーザーへの影響 | 復旧方法 |
|---------|------|---------------|---------|
| 1. TenantUser一覧取得 | 成功（Cosmos DB） | 正常 | - |
| 2. ユーザー詳細取得失敗 | 部分的失敗を許容 | 一部ユーザーの詳細が「利用不可」と表示 | サービス復旧後にリロード |
| 3. レスポンス返却 | 取得できたデータのみ返却 | 画面は表示される（一部情報欠落） | 手動リロード |

**実装**:
```python
async def list_tenant_users(tenant_id: str):
    """
    ユーザー一覧取得（認証認可サービスダウン時の動作）
    
    Degradation:
        - 認証認可サービスダウン → 基本情報のみ表示
        - 部分的失敗を許容（他ユーザーは表示）
    """
    # 1. TenantUser一覧取得（Cosmos DB、確実に成功）
    tenant_users = await tenant_user_repository.list_by_tenant(tenant_id)
    
    # 2. ユーザー詳細を並列取得（失敗を許容）
    results = []
    for tenant_user in tenant_users:
        try:
            user_details = await get_user_details(tenant_user.user_id)
            results.append({
                "tenant_user": tenant_user,
                "user_details": user_details
            })
        except HTTPException as e:
            # 認証認可サービスダウン時はスキップ
            logger.warning(f"Failed to fetch user details: {e}")
            results.append({
                "tenant_user": tenant_user,
                "user_details": {
                    "user_id": tenant_user.user_id,
                    "error": "Details unavailable"
                }
            })
    
    return results
```

#### 監視とアラート

**CloudWatch/Application Insights メトリクス**:
- `auth_service_availability`: 認証認可サービスの可用性（%）
- `auth_service_timeout_count`: タイムアウト発生回数
- `user_invitation_failure_rate`: ユーザー招待失敗率（%）

**アラート設定**:
- 認証認可サービス可用性 < 99% → 運用チームに通知
- タイムアウト発生回数 > 10件/分 → 運用チームに通知
- ユーザー招待失敗率 > 5% → 運用チームに通知

### 12.5 サービス間認証API Key方式の選択理由

#### 背景
サービス間通信の認証方式として、以下の選択肢があります：
1. **API Key（共有秘密鍵）** - **Phase 1採用**
2. **OAuth 2.0 Client Credentials**
3. **相互TLS（mTLS）**
4. **JWT（サービス用）**

#### 選択理由

| 観点 | API Key（採用） | OAuth 2.0 | mTLS | JWT（サービス用） |
|-----|---------------|-----------|------|----------------|
| **実装容易性** | ○（環境変数のみ） | △（認可サーバー必要） | △（証明書管理必要） | △（トークン更新ロジック必要） |
| **セキュリティ** | △（鍵漏洩リスク） | ○ | ◎（最高） | ○ |
| **パフォーマンス** | ◎（最速） | △（トークン取得必要） | △（TLS handshake） | ○ |
| **Phase 1適合** | ◎ | △（過剰） | △（過剰） | ○ |
| **Phase 2移行** | ○（段階的移行可能） | ◎ | ◎ | ◎ |

**結論**: Phase 1ではAPI Key、Phase 2でOAuth 2.0に移行

**Phase 1でAPI Keyを採用する理由**:
1. **実装のシンプルさ**
   - 環境変数に`SERVICE_API_KEY`を設定するのみ
   - 追加のインフラ不要
2. **デバッグの容易さ**
   - リクエストヘッダーで認証を確認しやすい
   - トークン有効期限切れなどの問題がない
3. **パフォーマンス**
   - 認証オーバーヘッドが最小
   - トークン取得の往復通信が不要

**Phase 2での改善計画**:
- Azure Key Vaultでの秘密鍵管理
- OAuth 2.0 Client Credentialsへの移行
- mTLSの導入（Azureネイティブ機能活用）

**セキュリティ対策（Phase 1）**:
- API KeyはAzure Key Vaultに保存（Phase 2前倒し推奨）
- API Keyのローテーション手順の整備
- アクセスログの記録（Application Insights）

---

## 12. 成功の定義

### 12.1 短期（Phase 1）

- 全ての受け入れ基準を満たす
- テストカバレッジ 75%以上
- パフォーマンス目標達成
- タスク16（Frontend - テナント管理画面）が本タスクのAPIを使用して実装可能

### 12.2 長期（Phase 2以降）

- ユーザー招待の成功率 99.9%以上
- ドメイン検証の成功率 95%以上
- ユーザー招待時間 < 5分（管理操作含む）
- ユーザー満足度向上

---

## 13. 参照ドキュメント

- [タスク05 - テナント管理サービス - コアAPI](./05-テナント管理サービス-コアAPI.md)
- [タスク03 - 認証認可サービス - コアAPI](./03-認証認可サービス-コアAPI.md)
- [コンポーネント設計 - テナント管理サービス](../../arch/components/README.md#4-テナント管理サービス)
- [API設計 - テナント管理サービスAPI](../../arch/api/README.md#4-テナント管理サービスapi)
- [データモデル設計 - テナント管理サービス](../../arch/data/README.md#3-テナント管理サービス-tenant-コンテナ)
- [セキュリティ設計 - テナント分離](../../arch/security/README.md#32-テナント分離)

---

## 14. 付録

### 14.1 環境変数

```bash
# Cosmos DB接続
COSMOS_CONNECTION_STRING=AccountEndpoint=https://...
COSMOS_DATABASE_NAME=management-app
COSMOS_TENANT_CONTAINER_NAME=tenants

# 認証認可サービス連携
AUTH_SERVICE_URL=http://auth-service:8000
# サービス間認証用API Key（Phase 1）
SERVICE_API_KEY=your-service-api-key-minimum-32-characters-long
# Phase 2: Azure Key Vault参照
# SERVICE_API_KEY=@Microsoft.KeyVault(SecretUri=https://your-vault.vault.azure.net/secrets/service-api-key/)

# 認証認可サービスタイムアウト設定
AUTH_SERVICE_TIMEOUT=2.0  # 秒
AUTH_SERVICE_RETRY_MAX_ATTEMPTS=3
AUTH_SERVICE_RETRY_BACKOFF_MIN=0.1  # 秒
AUTH_SERVICE_RETRY_BACKOFF_MAX=1.0  # 秒

# DNS検証設定
DNS_VERIFICATION_TIMEOUT=5.0  # 秒
DNS_VERIFICATION_RETRY_MAX_ATTEMPTS=3
DNS_VERIFICATION_RETRY_INTERVAL=1.0  # 秒

# JWT検証（認証認可サービスと共有）
JWT_SECRET_KEY=your-secure-secret-key-64-bytes-or-longer
JWT_ALGORITHM=HS256

# ロギング
LOG_LEVEL=INFO

# Application Insights
APPINSIGHTS_INSTRUMENTATIONKEY=your-instrumentation-key
APPINSIGHTS_CONNECTION_STRING=InstrumentationKey=...;IngestionEndpoint=...

# Cosmos DBリトライポリシー
COSMOS_RETRY_MAX_ATTEMPTS=3
COSMOS_RETRY_BACKOFF_MULTIPLIER=1.0  # 秒（指数バックオフ）
COSMOS_CONSISTENCY_LEVEL=Session  # Strong, BoundedStaleness, Session, ConsistentPrefix, Eventual
```

**環境変数の管理方針**:

| 環境 | 管理方法 | 理由 |
|-----|---------|------|
| **開発環境** | `.env`ファイル | ローカル開発の容易性 |
| **ステージング環境** | Azure App Service Configuration | 環境変数の一元管理 |
| **本番環境** | Azure Key Vault参照 | セキュリティ強化（秘密鍵の暗号化保存） |

**Phase 2での改善**:
```bash
# 全ての秘密情報をAzure Key Vaultから参照
SERVICE_API_KEY=@Microsoft.KeyVault(SecretUri=https://your-vault.vault.azure.net/secrets/service-api-key/)
JWT_SECRET_KEY=@Microsoft.KeyVault(SecretUri=https://your-vault.vault.azure.net/secrets/jwt-secret/)
COSMOS_CONNECTION_STRING=@Microsoft.KeyVault(SecretUri=https://your-vault.vault.azure.net/secrets/cosmos-connection/)
```

### 14.2 DNS検証手順（ユーザー向けドキュメント例）

```markdown
## ドメイン検証手順

1. テナント管理画面でドメインを追加
2. 検証トークンが表示されます（例: `txt-verification-a1b2c3d4...`）
3. DNSプロバイダーの管理画面にログイン
4. TXTレコードを追加:
   - 名前: `_tenant_verification.yourdomain.com`
   - タイプ: `TXT`
   - 値: `txt-verification-a1b2c3d4...`（表示された検証トークン）
   - TTL: 3600（1時間）
5. DNS設定を保存
6. DNS伝播を待機（最大48時間、通常は15分～1時間）
7. テナント管理画面で「検証」ボタンをクリック
8. 検証成功すると「検証済み」マークが表示されます

### トラブルシューティング

**検証が失敗する場合**:
- DNS設定が正しいか確認
- DNS伝播を待つ（最大48時間）
- `nslookup -type=TXT _tenant_verification.yourdomain.com`でTXTレコードを確認
```

---

**ドキュメント終了**

````
