# 002. トランクベース開発ワークフローの採用

**日付**: 2026-01-07  
**ステータス**: 承認  
**決定者**: 開発チーム、DevOpsチーム

## コンテキスト

以下をサポートするブランチ戦略と開発ワークフローを確立する必要があります：

- 継続的インテグレーションと継続的デリバリー
- メインブランチを常にデプロイ可能に保つ
- マージコンフリクトと統合問題を最小化
- 迅速な機能開発とデプロイを可能にする
- polyrepoアーキテクチャとうまく機能する
- 段階的ロールアウトのための機能フラグをサポート

一般的なブランチ戦略：
- Git Flow: 長期的な機能とリリースブランチ
- GitHub Flow: メインにマージされる機能ブランチ
- トランクベース開発: 機能フラグ付きの短期的な機能ブランチ

## 決定

以下のプラクティスで**トランクベース開発**を採用します：

### コア原則

1. **メインブランチは常にデプロイ可能**
   - 必須のレビューとCIチェックで保護
   - メインにマージされるすべてのコードは本番環境対応
   - マージ前に自動テストが成功する必要

2. **短期的な機能ブランチ**
   - 最大寿命：2-3日（理想的には1日未満）
   - 最新のメインからブランチ
   - プルリクエスト経由でメインにマージ
   - マージ後に削除

3. **未完成機能の機能フラグ**
   - 2日以上かかる機能は機能フラグの後ろに隠す
   - 環境変数制御のフラグ
   - 機能が安定したらフラグを削除（1-2リリース後）

4. **継続的インテグレーション**
   - すべてのコミットで自動テスト
   - すべてのPRでビルド検証
   - すべての変更にコードレビューが必要

### ブランチ命名規則

```
feature/description     # 新機能
fix/description        # バグ修正
docs/description       # ドキュメント
refactor/description   # コードリファクタリング
test/description       # テスト追加
chore/description      # メンテナンスタスク
```

### ワークフロー例

```bash
# 1. メインから開始
git checkout main
git pull --recurse-submodules

# 2. 短期的な機能ブランチを作成
git checkout -b feature/user-profile-api

# 3. 開発し頻繁にコミット
git commit -m "feat(user): プロファイルエンドポイントを追加"
git commit -m "test(user): プロファイルテストを追加"

# 4. ブランチを最新に保つ（必要な場合）
git checkout main && git pull
git checkout feature/user-profile-api
git rebase main

# 5. プッシュしてPRを作成（2日以内）
git push origin feature/user-profile-api
# GitHubでPRを作成

# 6. マージしてブランチを削除
# （承認後GitHubで実行）
```

### 機能フラグパターン

より多くの時間を必要とする機能の場合：

```typescript
// コードで
if (process.env.FEATURE_NEW_DASHBOARD === 'enabled') {
  return <NewDashboard />;
}
return <OldDashboard />;
```

```bash
# .env.local（開発環境）
FEATURE_NEW_DASHBOARD=enabled

# .env.staging（ステージング環境）
FEATURE_NEW_DASHBOARD=enabled

# .env.production（本番環境）
FEATURE_NEW_DASHBOARD=disabled  # 準備ができるまで
```

## 結果

### ポジティブな結果

- **高速な統合**: 変更が継続的に統合され、マージコンフリクトが減少
- **常にデプロイ可能**: メインブランチはいつでもリリース可能
- **リスク削減**: 小さく頻繁なマージはレビューが容易でリスクが低い
- **高速なフィードバック**: 開発者は変更に対して迅速なフィードバックを得る
- **簡素化されたプロセス**: 管理および維持するブランチが少ない
- **より良いコラボレーション**: チームは変更を迅速に確認し、調整が改善
- **CI/CDをサポート**: 自動デプロイパイプラインに自然にフィット
- **ロールバックが容易**: 小さな変更は問題の特定と復元が容易

### ネガティブな結果

- **規律が必要**: チームは短期的なブランチにコミットする必要
- **機能フラグのオーバーヘッド**: 機能フラグの管理には複雑性が追加
- **良いテストが必要**: 不十分なテストではバグがメインに入る可能性
- **文化的シフト**: 長期的なブランチに慣れたチームは適応が必要
- **コードレビューのプレッシャー**: フローを維持するために迅速なPRターンアラウンドが期待される

### 中立的な結果

- 機能が安定した後、機能フラグのクリーンアップが必要
- 強力な自動テストインフラストラクチャが必要
- チームはトランクベースのプラクティスのトレーニングが必要

## 検討した代替案

### 代替案1: Git Flow

**説明**: 長期的な開発ブランチ、リリースブランチ、機能ブランチは数週間存在可能。

**長所**:
- 多くの開発者に馴染みがある
- 開発コードと本番コードの明確な分離
- 構造化されたリリースプロセス
- 複数のリリースを並行して準備可能

**短所**:
- 多くのブランチタイプで複雑なブランチモデル
- 長期的なブランチはマージコンフリクトを増やす
- 遅延した統合はリスクを増やす
- 常にデプロイ可能な状態の維持が難しい
- リリースブランチがオーバーヘッドを追加
- 継続的デリバリーには理想的でない

**却下理由**: 私たちのニーズには複雑すぎて、継続的デリバリーの目標と矛盾します。長期的なブランチは統合リスクを増やし、開発速度を遅くします。

### 代替案2: GitHub Flow

**説明**: 機能ブランチが直接メインにマージされる、開発ブランチなし。

**長所**:
- Git Flowよりシンプル
- メインブランチはデプロイ可能
- 継続的デリバリーに適している
- 理解しやすい

**短所**:
- 機能ブランチの寿命に関するガイダンスなし
- 規律なしで長期的なブランチにつながる可能性
- 明示的な機能フラグ戦略なし
- トランクベースより規定的でない

**却下理由**: トランクベースに似ているが、より規定が少ないです。短期的なブランチと機能フラグに関するトランクベース開発の明示的なガイダンスを好みます。

## 実装ノート

### チームオンボーディング

1. **トレーニングセッション**: トランクベース開発に関するワークショップを実施
2. **ドキュメント**: このADRとCONTRIBUTING.mdを参照
3. **ペアプログラミング**: 新しいチームメンバーは経験豊富な開発者とペア
4. **PRテンプレート**: ブランチ寿命を思い出させるPRテンプレートを使用

### 機能フラグ実装

1. **環境変数**: フラグ設定に`.env`ファイルを使用
2. **命名規則**: すべての機能フラグに`FEATURE_<NAME>`
3. **ドキュメント**: 中央の場所ですべてのアクティブなフラグをドキュメント化
4. **クリーンアップスケジュール**: 四半期ごとにフラグをレビューして削除
5. **フラグタイプ**:
   - 開発フラグ（機能完了後に削除）
   - 運用フラグ（永続的、システム動作を制御）

### CI/CDパイプライン

1. **PRチェック**（マージ前に必須）:
   - リンティング
   - 型チェック
   - ユニットテスト（80%以上のカバレッジ）
   - 統合テスト
   - ビルド検証

2. **マージ後**（自動）:
   - ステージングにデプロイ
   - スモークテストを実行
   - 本番デプロイには手動承認

### 監視

- ブランチ寿命メトリクスを追跡
- メインブランチの安定性を監視（ビルド成功率）
- コミットから本番までの時間を測定
- 機能フラグの使用とクリーンアップを追跡

## 検証

以下によってこの決定を検証します：

**成功メトリクス**:
- 平均ブランチ寿命 < 2日
- メインブランチビルド成功率 > 95%
- コミットから本番までの時間 < 1日
- マージコンフリクト率 < 5%
- 開発者満足度スコア

**レビュータイムライン**: 採用後3か月

**レビュー基準**:
- 開発者は短期的なブランチを維持できていますか？
- メインブランチの安定性は維持されていますか？
- 機能フラグは適切に管理されていますか？
- チームはワークフローに満足していますか？

## 参考資料

- [Trunk-Based Development](https://trunkbaseddevelopment.com/)
- [Feature Flags Best Practices](https://martinfowler.com/articles/feature-toggles.html)
- [Continuous Integration by Martin Fowler](https://martinfowler.com/articles/continuousIntegration.html)
- [Git Flow vs Trunk-Based Development](https://www.toptal.com/software/trunk-based-development-git-flow)
- このリポジトリのCONTRIBUTING.md

---

**最終更新**: 2026-01-07
